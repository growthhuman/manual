KSH(1)                                                                  KSH(1)



NNAAMMEE
       ksh,  rksh,  pfksh  - KornShell, a standard/restricted command and pro-
       gramming language

SSYYNNOOPPSSIISS
       kksshh [ ±±aabbcceeffhhiikknnoopprrssttuuvvxxBBCCDDPP ] [ --RR file ] [ ±±oo option ] ... [  --  ]  [
       arg ... ]

DDEESSCCRRIIPPTTIIOONN
       _K_s_h  is  a command and programming language that executes commands read
       from a terminal or a file.  _R_k_s_h is a restricted version of the command
       interpreter  _k_s_h;  it is used to set up login names and execution envi-
       ronments whose capabilities are more controlled than those of the stan-
       dard  shell.   _R_p_f_k_s_h  is a profile shell version of the command inter-
       preter _k_s_h; it is used to to execute commands with the attributes spec-
       ified by the user’s profiles (see _p_f_e_x_e_c(1)).  See _I_n_v_o_c_a_t_i_o_n below for
       the meaning of arguments to the shell.

       NNOOTTEE:: PPffkksshh, RRppffkksshh and ppffeexxeecc parts are not related to Linux  systems.
       RRkksshh can be used as rksh symlink to kksshh9933 or as kksshh --rr.

   DDeeffiinniittiioonnss..
       A _m_e_t_a_c_h_a_r_a_c_t_e_r is one of the following characters:

              ;;   &&   ((   ))   ││   <<   >>   nneeww--lliinnee   ssppaaccee   ttaabb

       A  _b_l_a_n_k  is a ttaabb or a ssppaaccee.  An _i_d_e_n_t_i_f_i_e_r is a sequence of letters,
       digits, or underscores starting with a letter or  underscore.   Identi-
       fiers  are used as components of _v_a_r_i_a_b_l_e names.  A _v_n_a_m_e is a sequence
       of one or more identifiers separated by a .. and optionally preceded  by
       a  ...   Vnames  are  used  as function and variable names.  A _w_o_r_d is a
       sequence of _c_h_a_r_a_c_t_e_r_s from the character set defined  by  the  current
       locale, excluding non-quoted _m_e_t_a_c_h_a_r_a_c_t_e_r_s.

       A  _c_o_m_m_a_n_d  is a sequence of characters in the syntax of the shell lan-
       guage.  The shell reads each command and carries out the desired action
       either  directly or by invoking separate utilities.  A built-in command
       is a command that is carried out by the shell itself without creating a
       separate  process.   Some  commands are built-in purely for convenience
       and are not documented here.  Built-ins that cause side effects in  the
       shell environment and built-ins that are found before performing a path
       search (see _E_x_e_c_u_t_i_o_n below) are documented here.  For historical  rea-
       sons,  some  of these built-ins behave differently than other built-ins
       and are called _s_p_e_c_i_a_l _b_u_i_l_t_-_i_n_s.

   CCoommmmaannddss..
       A _s_i_m_p_l_e_-_c_o_m_m_a_n_d is  a  list  of  variable  assignments  (see  _V_a_r_i_a_b_l_e
       _A_s_s_i_g_n_m_e_n_t_s  below) or a sequence of _b_l_a_n_k separated words which may be
       preceded by a list of variable  assignments  (see  _E_n_v_i_r_o_n_m_e_n_t  below).
       The  first  word  specifies  the  name  of  the command to be executed.
       Except as specified below, the remaining words are passed as  arguments
       to  the invoked command.  The command name is passed as argument 0 (see
       _e_x_e_c(2)).  The _v_a_l_u_e of a simple-command is its exit status;  0-255  if
       it  terminates  normally;  256+_s_i_g_n_u_m  if it terminates abnormally (the
       name of the signal corresponding to the exit status can be obtained via
       the --ll option of the kkiillll built-in utility).

       A  _p_i_p_e_l_i_n_e  is a sequence of one or more _c_o_m_m_a_n_d_s separated by ││.  The
       standard output of each command but the last is connected by a  _p_i_p_e(2)
       to the standard input of the next command.  Each command, except possi-
       bly the last, is run as a separate process; the  shell  waits  for  the
       last  command  to terminate.  The exit status of a pipeline is the exit
       status of the last command unless the ppiippeeffaaiill option is enabled.  Each
       pipeline  can be preceded by the _r_e_s_e_r_v_e_d _w_o_r_d !!  which causes the exit
       status of the pipeline to become 0 if the exit status of the last  com-
       mand is non-zero, and 1 if the exit status of the last command is 0.

       A  _l_i_s_t  is  a sequence of one or more pipelines separated by ;;, &&, ││&&,
       &&&&, or ││││, and optionally terminated by ;;, &&, or  ││&&.   Of  these  five
       symbols,  ;;,  &&, and ││&& have equal precedence, which is lower than that
       of &&&& and ││││.  The symbols &&&& and ││││ also  have  equal  precedence.   A
       semicolon (;;) causes sequential execution of the preceding pipeline; an
       ampersand (&&) causes asynchronous execution of the  preceding  pipeline
       (i.e.,  the shell does _n_o_t wait for that pipeline to finish).  The sym-
       bol ││&& causes asynchronous execution of the preceding pipeline  with  a
       two-way  pipe  established  to the parent shell; the standard input and
       output of the spawned pipeline can be written to and read from  by  the
       parent shell by applying the redirection operators <<&& and >>&& with arg pp
       to commands and by using --pp option of the built-in  commands  rreeaadd  and
       pprriinntt described later.  The symbol &&&& (││││) causes the _l_i_s_t following it
       to be executed only if the preceding pipeline returns a zero (non-zero)
       value.   One  or more new-lines may appear in a _l_i_s_t instead of a semi-
       colon, to delimit a command.  The first _i_t_e_m  of the first _p_i_p_e_l_i_n_e  of
       a  _l_i_s_t  that is a simple command not beginning with a redirection, and
       not occurring within a wwhhiillee, uunnttiill, or iiff _l_i_s_t, can be preceded  by  a
       semicolon.   This  semicolon  is  ignored  unless  the sshhoowwmmee option is
       enabled as described with the sseett built-in below.

       A _c_o_m_m_a_n_d is either a simple-command or one of the  following.   Unless
       otherwise  stated,  the value returned by a command is that of the last
       simple-command executed in the command.

       ffoorr _v_n_a_m_e [ iinn _w_o_r_d ... ] ;;ddoo _l_i_s_t ;;ddoonnee
              Each time a ffoorr command is executed, _v_n_a_m_e is set  to  the  next
              _w_o_r_d  taken  from the iinn _w_o_r_d list.  If iinn _w_o_r_d ...  is omitted,
              then the ffoorr command executes the ddoo _l_i_s_t once  for  each  posi-
              tional  parameter  that  is  set  starting from 11 (see _P_a_r_a_m_e_t_e_r
              _E_x_p_a_n_s_i_o_n below).  Execution ends when there are no  more  words
              in the list.

       ffoorr (((( [_e_x_p_r_1] ;; [_e_x_p_r_2] ;; [_e_x_p_r_3] )))) ;;ddoo _l_i_s_t ;;ddoonnee
              The  arithmetic  expression _e_x_p_r_1 is evaluated first (see _A_r_i_t_h_-
              _m_e_t_i_c _e_v_a_l_u_a_t_i_o_n below).  The  arithmetic  expression  _e_x_p_r_2  is
              repeatedly  evaluated  until  it evaluates to zero and when non-
              zero, _l_i_s_t is executed and the arithmetic expression _e_x_p_r_3 eval-
              uated.   If  any expression is omitted, then it behaves as if it
              evaluated to 1.

       sseelleecctt _v_n_a_m_e [ iinn _w_o_r_d ... ] ;;ddoo _l_i_s_t ;;ddoonnee
              A sseelleecctt command prints on standard error  (file  descriptor  2)
              the set of _w_o_r_ds, each preceded by a number.  If iinn _w_o_r_d ...  is
              omitted, then the positional parameters starting from 11 are used
              instead  (see  _P_a_r_a_m_e_t_e_r  _E_x_p_a_n_s_i_o_n  below).   The PPSS33 prompt is
              printed and a line is read from the  standard  input.   If  this
              line consists of the number of one of the listed _w_o_r_ds, then the
              value of the variable _v_n_a_m_e is set to the _w_o_r_d corresponding  to
              this  number.   If  this  line  is  empty, the selection list is
              printed again.  Otherwise the value of the variable _v_n_a_m_e is set
              to  _n_u_l_l.   The contents of the line read from standard input is
              saved in the variable RREEPPLLYY.  The  _l_i_s_t  is  executed  for  each
              selection  until  a bbrreeaakk or _e_n_d_-_o_f_-_f_i_l_e is encountered.  If the
              RREEPPLLYY variable is set to _n_u_l_l by the execution of _l_i_s_t, then the
              selection  list  is printed before displaying the PPSS33 prompt for
              the next selection.

       ccaassee _w_o_r_d iinn [ [((]_p_a_t_t_e_r_n [ │ _p_a_t_t_e_r_n ] ... )) _l_i_s_t ;;;; ] ... eessaacc
              A ccaassee command executes the _l_i_s_t associated with the first  _p_a_t_-
              _t_e_r_n that matches _w_o_r_d.  The form of the patterns is the same as
              that used for file-name generation  (see  _F_i_l_e  _N_a_m_e  _G_e_n_e_r_a_t_i_o_n
              below).   The ;;;; operator causes execution of ccaassee to terminate.
              If ;;&& is used in place of ;;;; the next subsequent list,  if  any,
              is executed.

       iiff _l_i_s_t ;;tthheenn _l_i_s_t [ ;;eelliiff _l_i_s_t ;;tthheenn _l_i_s_t ] ... [ ;;eellssee _l_i_s_t ] ;;ffii
              The _l_i_s_t following iiff is executed and, if it returns a zero exit
              status, the _l_i_s_t following the first tthheenn is  executed.   Other-
              wise,  the  _l_i_s_t following eelliiff is executed and, if its value is
              zero, the _l_i_s_t following the next  tthheenn  is  executed.   Failing
              each successive eelliiff _l_i_s_t, the eellssee _l_i_s_t is executed.  If the iiff
              _l_i_s_t has non-zero exit status and there is no  eellssee  _l_i_s_t,  then
              the iiff command returns a zero exit status.

       wwhhiillee _l_i_s_t ;;ddoo _l_i_s_t ;;ddoonnee
       uunnttiill _l_i_s_t ;;ddoo _l_i_s_t ;;ddoonnee
              A  wwhhiillee  command repeatedly executes the wwhhiillee _l_i_s_t and, if the
              exit status of the last command in the list  is  zero,  executes
              the  ddoo  _l_i_s_t; otherwise the loop terminates.  If no commands in
              the ddoo _l_i_s_t are executed, then the wwhhiillee command returns a  zero
              exit  status;  uunnttiill may be used in place of wwhhiillee to negate the
              loop termination test.

       ((((_e_x_p_r_e_s_s_i_o_n))))
              The _e_x_p_r_e_s_s_i_o_n is evaluated using the rules for arithmetic eval-
              uation  described below.  If the value of the arithmetic expres-
              sion is non-zero, the exit status is 0, otherwise the exit  sta-
              tus is 1.

       ((_l_i_s_t))
              Execute _l_i_s_t in a separate environment.  Note, that if two adja-
              cent open parentheses are needed for nesting, a  space  must  be
              inserted  to  avoid  evaluation  as  an  arithmetic  command  as
              described above.

       {{ _l_i_s_t;;}}
              _l_i_s_t is simply executed.  Note that unlike the metacharacters  ((
              and  )),  {{ and }} are _r_e_s_e_r_v_e_d _w_o_r_ds and must occur at the begin-
              ning of a line or after a ;; in order to be recognized.

       [[[[ _e_x_p_r_e_s_s_i_o_n ]]]]
              Evaluates _e_x_p_r_e_s_s_i_o_n and returns a zero exit status when _e_x_p_r_e_s_-
              _s_i_o_n is true.  See _C_o_n_d_i_t_i_o_n_a_l _E_x_p_r_e_s_s_i_o_n_s below, for a descrip-
              tion of _e_x_p_r_e_s_s_i_o_n.

       ffuunnccttiioonn _v_a_r_n_a_m_e {{ _l_i_s_t ;;}}
       _v_a_r_n_a_m_e (()) {{ _l_i_s_t ;;}}
              Define a function which is referenced by  _v_a_r_n_a_m_e.   A  function
              whose  _v_a_r_n_a_m_e contains a ..  is called a discipline function and
              the portion of the _v_a_r_n_a_m_e preceding the last ..  must  refer  to
              an  existing  variable.  The body of the function is the _l_i_s_t of
              commands between {{ and }}.  A function defined with the  ffuunnccttiioonn
              _v_a_r_n_a_m_e syntax can also be used as an argument to the ..  special
              built-in command to get the equivalent behavior as if  the  _v_a_r_-
              _n_a_m_e(()) syntax were used to define it.  (See _F_u_n_c_t_i_o_n_s below.)

       ttiimmee [ _p_i_p_e_l_i_n_e ]
              If  _p_i_p_e_l_i_n_e is omitted the user and system time for the current
              shell and completed  child  processes  is  printed  on  standard
              error.   Otherwise, _p_i_p_e_l_i_n_e is executed and the elapsed time as
              well as the user and system time are printed on standard  error.
              The TTIIMMEEFFOORRMMAATT variable may be set to a format string that spec-
              ifies how the timing information should be displayed.  See SShheellll
              VVaarriiaabblleess below for a description of the TTIIMMEEFFOORRMMAATT variable.

       The  following reserved words are recognized as reserved only when they
       are the first word of a command and are not quoted:

       iiff tthheenn eellssee eelliiff ffii ccaassee eessaacc ffoorr wwhhiillee uunnttiill ddoo  ddoonnee  {{  }}  ffuunnccttiioonn
       sseelleecctt ttiimmee [[[[ ]]]] !!

   VVaarriiaabbllee AAssssiiggnnmmeennttss..
       One  or  more variable assignments can start a simple command or can be
       arguments to the ttyyppeesseett, eennuumm, eexxppoorrtt, or  rreeaaddoonnllyy  special  built-in
       commands  as  well  as  to other declaration commands created as types.
       The syntax for an _a_s_s_i_g_n_m_e_n_t is of the form:

       _v_a_r_n_a_m_e==_w_o_r_d
       _v_a_r_n_a_m_e[[_w_o_r_d]]=_w_o_r_d
              No space is permitted between _v_a_r_n_a_m_e and the == or between == and
              _w_o_r_d.

       _v_a_r_n_a_m_e==((_a_s_s_i_g_n___l_i_s_t))
              No space is permitted between _v_a_r_n_a_m_e and the ==.  An _a_s_s_i_g_n___l_i_s_t
              can be one of the following:
                      _w_o_r_d ...
                             Indexed array assignment.
                      [[_w_o_r_d]]==_w_o_r_d ...
                             Associative array  assignment.   If  preceded  by
                             ttyyppeesseett  --aa  this  will  create  an indexed array
                             instead.
                      _a_s_s_i_g_n_m_e_n_t ...
                             Compound variable  assignment.   This  creates  a
                             compound  variable  _v_a_r_n_a_m_e with sub-variables of
                             the form _v_a_r_n_a_m_e.._n_a_m_e, where  _n_a_m_e  is  the  name
                             portion of _a_s_s_i_g_n_m_e_n_t.  The value of _v_a_r_n_a_m_e will
                             contain all the assignment elements.   Additional
                             assignments made to sub-variables of _v_a_r_n_a_m_e will
                             also be displayed as part of the  value  of  _v_a_r_-
                             _n_a_m_e.   If  no _a_s_s_i_g_n_m_e_n_ts are specified, _v_a_r_n_a_m_e
                             will be a compound variable allowing  subsequence
                             child elements to be defined.
                      ttyyppeesseett [_o_p_t_i_o_n_s] _a_s_s_i_g_n_m_e_n_t ...
                             Nested variable assignment.  Multiple assignments
                             can be specified by separating each of them  with
                             a  ;;.   The  previous  value  is unset before the
                             assignment.  Other declaration commands  such  as
                             rreeaaddoonnllyy,,  eennuumm,  and  other declaration commands
                             can be used in place of ttyyppeesseett.
                      .. _f_i_l_e_n_a_m_e
                             Include  the  assignment  commands  contained  in
                             _f_i_l_e_n_a_m_e.

       In addition, a ++== can be used in place of the == to signify adding to or
       appending to the previous value.  When ++== is applied to  an  arithmetic
       type,  _w_o_r_d  is  evaluated as an arithmetic expression and added to the
       current value.  When applied to a string variable, the value defined by
       _w_o_r_d  is appended to the value.  For compound assignments, the previous
       value is not unset and the new values are appended to the current  ones
       provided that the types are compatible.

       The  right  hand side of a variable assignment undergoes all the expan-
       sion listed below except word splitting, brace expansion, and file name
       generation.   When  the  left  hand side is an assignment is a compound
       variable and the right hand is the name of  a  compound  variable,  the
       compound  variable  on the right will be copied or appended to the com-
       pound variable on the left.

   CCoommmmeennttss..
       A word beginning with ## causes that word and all the following  charac-
       ters up to a new-line to be ignored.
   AAlliiaassiinngg..
       The  first  word of each command is replaced by the text of an aalliiaass if
       an aalliiaass for this word has been defined.  An aalliiaass name consists of any
       number of characters excluding metacharacters, quoting characters, file
       expansion characters,  parameter  expansion  and  command  substitution
       characters,  and ==.  The replacement string can contain any valid shell
       script including the metacharacters listed above.  The  first  word  of
       each  command in the replaced text, other than any that are in the pro-
       cess of being replaced, will be tested for aliases.  If the last  char-
       acter  of  the alias value is a _b_l_a_n_k then the word following the alias
       will also be checked for alias substitution.  Aliases can  be  used  to
       redefine  built-in commands but cannot be used to redefine the reserved
       words listed above.  Aliases can be created and listed with  the  aalliiaass
       command and can be removed with the uunnaalliiaass command.
       _A_l_i_a_s_i_n_g  is  performed  when scripts are read, not while they are exe-
       cuted.  Therefore, for an alias to take effect,  the  aalliiaass  definition
       command  has  to  be  executed  before the command which references the
       alias is read.
       The following aliases are compiled into the shell but can be  unset  or
       redefined:
                           aauuttoollooaadd==′′ttyyppeesseett --ffuu′′
                           ccoommmmaanndd==′′ccoommmmaanndd  ′′
                           ccoommppoouunndd==′′ttyyppeesseett --CC′′
                           ffcc==hhiisstt
                           ffllooaatt==′′ttyyppeesseett --llEE′′
                           ffuunnccttiioonnss==′′ttyyppeesseett --ff′′
                           hhaasshh==′′aalliiaass --tt ----′′
                           hhiissttoorryy==′′hhiisstt --ll′′
                           iinntteeggeerr==′′ttyyppeesseett --llii′′
                           nnaammeerreeff==′′ttyyppeesseett --nn′′
                           nnoohhuupp==′′nnoohhuupp  ′′
                           rr==′′hhiisstt --ss′′
                           rreeddiirreecctt==′′ccoommmmaanndd eexxeecc′′
                           ssoouurrccee==′′ccoommmmaanndd ..′′
                           ssttoopp==′′kkiillll --ss SSTTOOPP′′
                           ssuussppeenndd==′′kkiillll --ss SSTTOOPP $$$$′′
                           ttiimmeess==′′{{ {{ ttiimmee;;}} 22>>&&11;;}}′′
                           ttyyppee==′′wwhheennccee --vv′′

   TTiillddee SSuubbssttiittuuttiioonn..
       After  alias  substitution is performed, each word is checked to see if
       it begins with an unquoted ∼∼.  For tilde substitution, _w_o_r_d also refers
       to  the  _w_o_r_d  portion  of parameter expansion (see _P_a_r_a_m_e_t_e_r _E_x_p_a_n_s_i_o_n
       below).  If it does, then the word up to a // is checked to  see  if  it
       matches  a user name in the password database (See _g_e_t_p_w_n_a_m_e(3).)  If a
       match is found, the ∼∼ and the matched login name are  replaced  by  the
       login  directory of the matched user.  If no match is found, the origi-
       nal text is left unchanged.  A ∼∼ by itself, or in  front  of  a  //,  is
       replaced  by  $$HHOOMMEE.  A ∼∼ followed by a ++ or -- is replaced by the value
       of $$PPWWDD and $$OOLLDDPPWWDD respectively.

       In addition, when expanding a _v_a_r_i_a_b_l_e _a_s_s_i_g_n_m_e_n_t,  _t_i_l_d_e  substitution
       is attempted when the value of the assignment begins with a ∼∼, and when
       a ∼∼ appears after a ::.  The :: also terminates a ∼∼ login name.

   CCoommmmaanndd SSuubbssttiittuuttiioonn..
       The standard output from a command list enclosed  in  parentheses  pre-
       ceded  by  a dollar sign ( $$((_l_i_s_t)) ), or in a brace group preceded by a
       dollar sign ( $${{ _l_i_s_t;;}} ), or in a pair of grave accents  (````)  may  be
       used  as part or all of a word; trailing new-lines are removed.  In the
       second case, the {{ and }} are treated as a reserved words so that {{ must
       be  followed  by a _b_l_a_n_k and }} must appear at the beginning of the line
       or follow a ;;.  In the third (obsolete) form, the  string  between  the
       quotes  is  processed for special quoting characters before the command
       is executed (see _Q_u_o_t_i_n_g below).  The command substitution $$((ccaatt  ffiillee))
       can  be  replaced  by  the equivalent but faster $$((<<ffiillee)).  The command
       substitution $$((_n<<##)) will expand to the current  byte  offset  for  file
       descriptor _n.  Except for the second form, the command list is run in a
       subshell so that no side effects are possible.  For  the  second  form,
       the final }} will be recognized as a reserved word after any token.

   AArriitthhmmeettiicc SSuubbssttiittuuttiioonn..
       An  arithmetic  expression enclosed in double parentheses preceded by a
       dollar sign ( $$(((()))) ) is  replaced  by  the  value  of  the  arithmetic
       expression within the double parentheses.

   PPrroocceessss SSuubbssttiittuuttiioonn..
       This feature is only available on versions of the UNIX operating system
       that support the //ddeevv//ffdd directory for naming open files.  Each command
       argument  of  the  form  <<((_l_i_s_t)) or >>((_l_i_s_t)) will run process _l_i_s_t asyn-
       chronously connected to some file in //ddeevv//ffdd.  The name  of  this  file
       will  become  the  argument  to  the  command.   If  the form with >> is
       selected then writing on this file will provide input for _l_i_s_t.   If  <<
       is used, then the file passed as an argument will contain the output of
       the _l_i_s_t process.  For example,

              ppaassttee <<((ccuutt --ff11 _f_i_l_e_1)) <<((ccuutt --ff33 _f_i_l_e_2)) || tteeee >>((_p_r_o_c_e_s_s_1)) >>((_p_r_o_-
              _c_e_s_s_2))

       _c_u_t_s fields 1 and 3 from the files _f_i_l_e_1 and _f_i_l_e_2 respectively, _p_a_s_t_e_s
       the results together, and sends it to the processes _p_r_o_c_e_s_s_1  and  _p_r_o_-
       _c_e_s_s_2,  as  well as putting it onto the standard output.  Note that the
       file, which is passed as an argument to the command, is a UNIX  _p_i_p_e(2)
       so programs that expect to _l_s_e_e_k(2) on the file will not work.

       Process  substitution  of  the form <<((_l_i_s_t)) can also be used with the <<
       redirection operator which causes the output of  _l_i_s_t  to  be  standard
       input or the input for whatever file descriptor is specified.

   PPaarraammeetteerr EExxppaannssiioonn..
       A _p_a_r_a_m_e_t_e_r is a _v_a_r_i_a_b_l_e, one or more digits, or any of the characters
       ∗∗, @@, ##, ??, --, $$, and !!.  A _v_a_r_i_a_b_l_e is denoted by a _v_n_a_m_e.  To  create
       a variable whose _v_n_a_m_e contains a .., a variable whose _v_n_a_m_e consists of
       everything before the last .. must already  exist.   A  _v_a_r_i_a_b_l_e  has  a
       _v_a_l_u_e  and  zero  or more _a_t_t_r_i_b_u_t_e_s.  _V_a_r_i_a_b_l_e_s can be assigned _v_a_l_u_e_s
       and _a_t_t_r_i_b_u_t_e_s by using the  ttyyppeesseett  special  built-in  command.   The
       attributes  supported by the shell are described later with the ttyyppeesseett
       special  built-in  command.   Exported  variables   pass   values   and
       attributes to the environment.

       The  shell supports both indexed and associative arrays.  An element of
       an array variable is referenced by a _s_u_b_s_c_r_i_p_t.   A  _s_u_b_s_c_r_i_p_t  for  an
       indexed  array  is  denoted by an _a_r_i_t_h_m_e_t_i_c _e_x_p_r_e_s_s_i_o_n (see _A_r_i_t_h_m_e_t_i_c
       _e_v_a_l_u_a_t_i_o_n below) between a [[ and a ]].  To assign values to an  indexed
       array, use _v_n_a_m_e==((_v_a_l_u_e ...)) or sseett --AA _v_n_a_m_e  _v_a_l_u_e ... .  The value of
       all  non-negative  subscripts  must  be  in  the  range  of  0  through
       4,194,303.  A negative subscript is treated as an offset from the maxi-
       mum current index +1 so that -1 refers to the  last  element.   Indexed
       arrays  can  be declared with the --aa option to ttyyppeesseett..  Indexed arrays
       need not be declared.  Any reference to a variable with  a  valid  sub-
       script is legal and an array will be created if necessary.

       An  associative array is created with the --AA option to ttyyppeesseett..  A _s_u_b_-
       _s_c_r_i_p_t for an associative array is denoted by a string enclosed between
       [[ and ]].

       Referencing  any array without a subscript is equivalent to referencing
       the array with subscript 0.

       The _v_a_l_u_e of a _v_a_r_i_a_b_l_e may be assigned by writing:

              _v_n_a_m_e==_v_a_l_u_e [ _v_n_a_m_e==_v_a_l_u_e ] ...

       or
              _v_n_a_m_e[[_s_u_b_s_c_r_i_p_t]]==_v_a_l_u_e [ _v_n_a_m_e[[_s_u_b_s_c_r_i_p_t]]==_v_a_l_u_e ] ...
       Note that no space is allowed before or after the ==.
       A _n_a_m_e_r_e_f is a variable that is a reference  to  another  variable.   A
       nameref  is created with the --nn attribute of ttyyppeesseett.  The value of the
       variable at the time of the ttyyppeesseett command becomes the  variable  that
       will  be referenced whenever the nameref variable is used.  The name of
       a nameref cannot contain a ...  When a variable or  function  name  con-
       tains  a  ..,  and the portion of the name up to the first .. matches the
       name of a nameref, the variable referred to is  obtained  by  replacing
       the  nameref  portion  with  the name of the variable referenced by the
       nameref.  If a nameref is used as the index of a ffoorr loop, a name  ref-
       erence  is established for each item in the list.  A nameref provides a
       convenient way to refer to the variable inside a function whose name is
       passed  as  an  argument  to a function.  For example, if the name of a
       variable is passed as the first argument to a function, the command
              ttyyppeesseett --nn vvaarr==$$11
       inside the function causes references and assignments to vvaarr to be ref-
       erences  and  assignments to the variable whose name has been passed to
       the function.
       If any of the floating point attributes, --EE, --FF, or --XX, or the  integer
       attribute,  --ii,  is  set for _v_n_a_m_e, then the _v_a_l_u_e is subject to arith-
       metic evaluation as described below.
       Positional parameters, parameters denoted by a number, may be  assigned
       values with the sseett special built-in command.  Parameter $$00 is set from
       argument zero when the shell is invoked.
       The character $$ is used to introduce substitutable _p_a_r_a_m_e_t_e_r_s.
       $${{_p_a_r_a_m_e_t_e_r}}
              The shell reads all the characters from $${{ to the matching }}  as
              part  of the same word even if it contains braces or metacharac-
              ters.  The value, if any, of the parameter is substituted.   The
              braces  are  required  when  _p_a_r_a_m_e_t_e_r  is followed by a letter,
              digit, or underscore that is not to be interpreted  as  part  of
              its  name,  when the variable name contains a ...  The braces are
              also required when a variable is subscripted unless it  is  part
              of  an  Arithmetic  Expression  or a Conditional Expression.  If
              _p_a_r_a_m_e_t_e_r is one or more digits then it is a positional  parame-
              ter.   A  positional  parameter  of  more than one digit must be
              enclosed in braces.  If _p_a_r_a_m_e_t_e_r is ∗∗ or @@, then all the  posi-
              tional  parameters, starting with $$11, are substituted (separated
              by a field separator character).  If an array  _v_n_a_m_e  with  sub-
              script  ∗∗  @@,  or  of the form _s_u_b_1 ....  _s_u_b_2.  is used, then the
              value for each of the elements between _s_u_b_1 and  _s_u_b_2  inclusive
              (or  all  elements for ∗∗ and @@) is substituted, separated by the
              first character of the value of IIFFSS.
       $${{##_p_a_r_a_m_e_t_e_r}}
              If _p_a_r_a_m_e_t_e_r is ∗∗ or @@, the number of positional  parameters  is
              substituted.   Otherwise, the length of the value of the _p_a_r_a_m_e_-
              _t_e_r is substituted.
       $${{##_v_n_a_m_e[[**]]}}
       $${{##_v_n_a_m_e[[@@]]}}
              The number of elements in the array _v_n_a_m_e is substituted.

       $${{@@_v_n_a_m_e}}
              Expands to  the  type  name  (See  _T_y_p_e  _V_a_r_i_a_b_l_e_s    below)  or
              attributes of the variable referred to by _v_n_a_m_e.
       $${{!!_v_n_a_m_e}}
              Expands  to the name of the variable referred to by _v_n_a_m_e.  This
              will be _v_n_a_m_e except when _v_n_a_m_e is a name reference.
       $${{!!_v_n_a_m_e[[_s_u_b_s_c_r_i_p_t]]}}
              Expands to name of the subscript unless _s_u_b_s_c_r_i_p_t is **,  @@.   or
              of  the  form  _s_u_b_1  ....  _s_u_b_2.  When _s_u_b_s_c_r_i_p_t is **, the list of
              array subscripts for _v_n_a_m_e is generated.  For a variable that is
              not  an array, the value is 0 if the variable is set.  Otherwise
              it is null.  When _s_u_b_s_c_r_i_p_t is @@, same  as  above,  except  that
              when  used in double quotes, each array subscript yields a sepa-
              rate argument.  When _s_u_b_s_c_r_i_p_t is of the form _s_u_b_1 ....   _s_u_b_2  it
              expands  to  the list of subscripts between _s_u_b_1 and _s_u_b_2 inclu-
              sive using the same quoting rules as @@.
       $${{!!_p_r_e_f_i_x**}}
              Expands to the names of the variables  whose  names  begin  with
              _p_r_e_f_i_x.
       $${{_p_a_r_a_m_e_t_e_r::--_w_o_r_d}}
              If  _p_a_r_a_m_e_t_e_r  is set and is non-null then substitute its value;
              otherwise substitute _w_o_r_d.
       $${{_p_a_r_a_m_e_t_e_r::==_w_o_r_d}}
              If _p_a_r_a_m_e_t_e_r is not set or is null then  set  it  to  _w_o_r_d;  the
              value  of the parameter is then substituted.  Positional parame-
              ters may not be assigned to in this way.
       $${{_p_a_r_a_m_e_t_e_r::??_w_o_r_d}}
              If _p_a_r_a_m_e_t_e_r is set and is non-null then substitute  its  value;
              otherwise,  print  _w_o_r_d and exit from the shell (if not interac-
              tive).  If _w_o_r_d is omitted then a standard message is printed.
       $${{_p_a_r_a_m_e_t_e_r::++_w_o_r_d}}
              If _p_a_r_a_m_e_t_e_r is set and is non-null then substitute _w_o_r_d; other-
              wise substitute nothing.
       In the above, _w_o_r_d is not evaluated unless it is to be used as the sub-
       stituted string, so that, in the following  example,  ppwwdd  is  executed
       only if dd is not set or is null:
              print ${d:-$(pwd)}
       If  the  colon  (  ::  )) is omitted from the above expressions, then the
       shell only checks whether _p_a_r_a_m_e_t_e_r is set or not.
       $${{_p_a_r_a_m_e_t_e_r::_o_f_f_s_e_t::_l_e_n_g_t_h}}
       $${{_p_a_r_a_m_e_t_e_r::_o_f_f_s_e_t}}
              Expands to the portion of the value of _p_a_r_a_m_e_t_e_r starting at the
              character (counting from 00) determined by expanding _o_f_f_s_e_t as an
              arithmetic expression and consisting of the number of characters
              determined  by  the arithmetic expression defined by _l_e_n_g_t_h_.  In
              the second form, the remainder of the value is used.  If A nega-
              tive  _o_f_f_s_e_t  counts  backwards from the end of _p_a_r_a_m_e_t_e_r.  Note
              that one or more _b_l_a_n_ks is required in front of a minus sign  to
              prevent  the  shell  from  interpreting  the operator as ::--.  If
              _p_a_r_a_m_e_t_e_r is ∗∗ or @@, or is an array name indexed by ∗∗ or @@, then
              _o_f_f_s_e_t  and  _l_e_n_g_t_h  refer to the array index and number of ele-
              ments respectively.  A negative _o_f_f_s_e_t is taken relative to  one
              greater  than  the  highest  subscript  for indexed arrays.  The
              order for associate arrays is unspecified.
       $${{_p_a_r_a_m_e_t_e_r##_p_a_t_t_e_r_n}}
       $${{_p_a_r_a_m_e_t_e_r####_p_a_t_t_e_r_n}}
              If the shell _p_a_t_t_e_r_n matches  the  beginning  of  the  value  of
              _p_a_r_a_m_e_t_e_r,  then the value of this expansion is the value of the
              _p_a_r_a_m_e_t_e_r with the matched portion deleted; otherwise the  value
              of  this _p_a_r_a_m_e_t_e_r is substituted.  In the first form the small-
              est matching pattern is deleted  and  in  the  second  form  the
              largest matching pattern is deleted.  When _p_a_r_a_m_e_t_e_r is @@, **, or
              an array variable with subscript @@ or **, the substring operation
              is applied to each element in turn.

       $${{_p_a_r_a_m_e_t_e_r%%_p_a_t_t_e_r_n}}
       $${{_p_a_r_a_m_e_t_e_r%%%%_p_a_t_t_e_r_n}}
              If  the shell _p_a_t_t_e_r_n matches the end of the value of _p_a_r_a_m_e_t_e_r,
              then the value of this expansion is the value of  the  _p_a_r_a_m_e_t_e_r
              with the matched part deleted; otherwise substitute the value of
              _p_a_r_a_m_e_t_e_r.  In the first form the smallest matching  pattern  is
              deleted  and  in the second form the largest matching pattern is
              deleted.  When _p_a_r_a_m_e_t_e_r is @@, **, or an array variable with sub-
              script  @@  or **, the substring operation is applied to each ele-
              ment in turn.

       $${{_p_a_r_a_m_e_t_e_r//_p_a_t_t_e_r_n//_s_t_r_i_n_g}}
       $${{_p_a_r_a_m_e_t_e_r////_p_a_t_t_e_r_n//_s_t_r_i_n_g}}
       $${{_p_a_r_a_m_e_t_e_r//##_p_a_t_t_e_r_n//_s_t_r_i_n_g}}
       $${{_p_a_r_a_m_e_t_e_r//%%_p_a_t_t_e_r_n//_s_t_r_i_n_g}}
              Expands _p_a_r_a_m_e_t_e_r and replaces the longest match of _p_a_t_t_e_r_n with
              the  given  _s_t_r_i_n_g_.  Each occurrence of \\_n in _s_t_r_i_n_g is replaced
              by the portion of _p_a_r_a_m_e_t_e_r that matches the  _n-th  sub-pattern.
              In  the  first  form,  only  the  first occurrence of _p_a_t_t_e_r_n is
              replaced.  In  the  second  form,  each  match  for  _p_a_t_t_e_r_n  is
              replaced by the given _s_t_r_i_n_g_.  The third form restricts the pat-
              tern match to the beginning of the string while the fourth  form
              restricts  the  pattern  match  to  the end of the string.  When
              _s_t_r_i_n_g is null, the _p_a_t_t_e_r_n will be deleted and the //  in  front
              of  _s_t_r_i_n_g  may be omitted.  When _p_a_r_a_m_e_t_e_r is @@, **, or an array
              variable with subscript @@ or **, the  substitution  operation  is
              applied  to each element in turn.  In this case, the _s_t_r_i_n_g por-
              tion of _w_o_r_d will be re-evaluated for each element.

       The following parameters are automatically set by the shell:
              ##      The number of positional parameters in decimal.
              --      Options supplied to the shell on invocation or by the sseett
                     command.
              ??      The  decimal value returned by the last executed command.
              $$      The process number of this shell.
              __      Initially, the value of __ is an absolute pathname of  the
                     shell  or script being executed as passed in the _e_n_v_i_r_o_n_-
                     _m_e_n_t.  Subsequently it is assigned the last  argument  of
                     the previous command.  This parameter is not set for com-
                     mands which are asynchronous.   This  parameter  is  also
                     used  to  hold  the  name  of the matching MMAAIILL file when
                     checking for mail.  While defining a compound variable or
                     a  type,  __ is initialized as a reference to the compound
                     variable or type.  When a discipline function is invoked,
                     __  is  initialized as a reference to the variable associ-
                     ated with the call to this function.  Finally when  __  is
                     used  as the name of the first variable of a type defini-
                     tion, the new type is derived from the type of the  first
                     variable (See _T_y_p_e _V_a_r_i_a_b_l_e_s  below.).
              !!      The process number of the last background command invoked
                     or the most recent job put in the background with the  bbgg
                     built-in command.
              ..sshh..ccoommmmaanndd
                     When  processing a DDEEBBUUGG trap, this variable contains the
                     current command line that is about to run.
              ..sshh..eeddcchhaarr
                     This variable contains the value of the keyboard  charac-
                     ter  (or sequence of characters if the first character is
                     an ESC, ascii 003333) that has been entered when  processing
                     a  KKEEYYBBDD  trap (see _K_e_y _B_i_n_d_i_n_g_s below).  If the value is
                     changed as part of the trap action, then  the  new  value
                     replaces  the key (or key sequence) that caused the trap.
              ..sshh..eeddccooll
                     The character position of the cursor at the time  of  the
                     most recent KKEEYYBBDD trap.
              ..sshh..eeddmmooddee
                     The  value  is  set  to  ESC when processing a KKEEYYBBDD trap
                     while in vvii insert mode.  (See _V_i _E_d_i_t_i_n_g _M_o_d_e    below.)
                     Otherwise,  ..sshh..eeddmmooddee  is  null  when processing a KKEEYYBBDD
                     trap.
              ..sshh..eeddtteexxtt
                     The characters in the input buffer at  the  time  of  the
                     most  recent KKEEYYBBDD trap.  The value is null when not pro-
                     cessing a KKEEYYBBDD trap.
              ..sshh..ffiillee
                     The pathname of the file than contains the  current  com-
                     mand.
              ..sshh..ffuunn
                     The  name of the current function that is being executed.
              ..sshh..lleevveell
                     Set to the current function depth.  This can  be  changed
                     inside a DEBUG trap and will set the context to the spec-
                     ified level.
              ..sshh..lliinneennoo
                     Set during a DEBUG trap to the line number for the caller
                     of each function.
              ..sshh..mmaattcchh
                     An  indexed  array which stores the most recent match and
                     sub-pattern matches  after  conditional  pattern  matches
                     that match and after variables expansions using the oper-
                     ators ##, %%, or //.  The 00-th element stores  the  complete
                     match  and  the  _i-th.  element stores the _i-th submatch.
                     The ..sshh..mmaattcchh variable becomes unset  when  the  variable
                     that has expanded is assigned a new value.
              ..sshh..nnaammee
                     Set to the name of the variable at the time that a disci-
                     pline function is invoked.
              ..sshh..ssuubbssccrriipptt
                     Set to the name subscript of the  variable  at  the  time
                     that a discipline function is invoked.
              ..sshh..ssuubbsshheellll
                     The current depth for subshells and command substitution.
              ..sshh..vvaalluuee
                     Set to the value of the variable at the time that the sseett
                     or aappppeenndd discipline function is invoked.
              ..sshh..vveerrssiioonn
                     Set to a value that identifies the version of this shell.
              KKSSHH__VVEERRSSIIOONN
                     A name reference to ..sshh..vveerrssiioonn.
              LLIINNEENNOO The current line number within  the  script  or  function
                     being executed.
              OOLLDDPPWWDD The previous working directory set by the ccdd command.
              OOPPTTAARRGG The  value  of  the last option argument processed by the
                     ggeettooppttss built-in command.
              OOPPTTIINNDD The index of the last option argument  processed  by  the
                     ggeettooppttss built-in command.
              PPPPIIDD   The process number of the parent of the shell.
              PPWWDD    The present working directory set by the ccdd command.
              RRAANNDDOOMM Each  time this variable is referenced, a random integer,
                     uniformly distributed between 0 and 32767, is  generated.
                     The  sequence  of  random  numbers  can be initialized by
                     assigning a numeric value to RRAANNDDOOMM.
              RREEPPLLYY  This variable is set by the sseelleecctt statement and  by  the
                     rreeaadd built-in command when no arguments are supplied.
              SSEECCOONNDDSS
                     Each time this variable is referenced, the number of sec-
                     onds since shell invocation is returned.  If  this  vari-
                     able  is  assigned  a value, then the value returned upon
                     reference will be the value that was  assigned  plus  the
                     number of seconds since the assignment.
              SSHHLLVVLL  An  integer  variable  the  is  incremented each time the
                     shell is invoked and is exported.  If SSHHLLVVLL is not in the
                     environment when the shell is invoked, it is set to 1.

       The following variables are used by the shell:
              CCDDPPAATTHH The search path for the ccdd command.
              CCOOLLUUMMNNSS
                     If  this variable is set, the value is used to define the
                     width of the edit window for the shell edit modes and for
                     printing sseelleecctt lists.
              EEDDIITTOORR If  the  VVIISSUUAALL  variable  is  not set, the value of this
                     variable will be checked for the  patterns  as  described
                     with  VVIISSUUAALL  below  and the corresponding editing option
                     (see Special Command sseett below) will be turned on.
              EENNVV    If this variable is set, then parameter  expansion,  com-
                     mand  substitution,  and arithmetic substitution are per-
                     formed on the value  to  generate  the  pathname  of  the
                     script  that  will  be executed when the shell is invoked
                     interactively (see _I_n_v_o_c_a_t_i_o_n below).  This file is typi-
                     cally  used  for  aalliiaass  and  ffuunnccttiioonn  definitions.  The
                     default value is $$HHOOMMEE//..kksshhrrcc.  On systems that support a
                     system  wide   //eettcc//kksshh..kksshhrrcc initialization file, if the
                     filename generated by the expansion of  EENNVV  begins  with
                     //..//  or ..//..// the system wide initialization file will not
                     be executed.
              FFCCEEDDIITT Obsolete name for the default editor name  for  the  hhiisstt
                     command.  FFCCEEDDIITT is not used when HHIISSTTEEDDIITT is set.
              FFIIGGNNOORREE
                     A  pattern that defines the set of filenames that will be
                     ignored when performing filename matching.
              FFPPAATTHH  The search path for function definitions.   The  directo-
                     ries  in  this path are searched for a file with the same
                     name as the function or command when a function with  the
                     --uu  attribute  is  referenced  and  when a command is not
                     found.  If an executable file with the name of that  com-
                     mand  is  found, then it is read and executed in the cur-
                     rent environment.  Unlike  PPAATTHH,  the  current  directory
                     must  be  represented  explicitly  by  ..   rather than by
                     adjacent :: characters or a beginning or ending ::.
              HHIISSTTCCMMDD
                     Number of the current command in the history file.
              HHIISSTTEEDDIITT
                     Name for the default editor name for the hhiisstt command.
              HHIISSTTFFIILLEE
                     If this variable is set when the shell is  invoked,  then
                     the  value  is the pathname of the file that will be used
                     to  store  the  command  history  (see  _C_o_m_m_a_n_d  _R_e_-_e_n_t_r_y
                     below).
              HHIISSTTSSIIZZEE
                     If  this  variable is set when the shell is invoked, then
                     the number of previously entered commands that are acces-
                     sible by this shell will be greater than or equal to this
                     number.  The default is 512.
              HHOOMMEE   The default argument (home directory) for the ccdd command.
              IIFFSS    Internal  field separators, normally ssppaaccee, ttaabb, and nneeww--
                     lliinnee that are used to separate  the  results  of  command
                     substitution  or  parameter  expansion  and  to  separate
                     fields with the built-in command rreeaadd.  The first charac-
                     ter of the IIFFSS variable is used to separate arguments for
                     the ""$$∗∗"" substitution (see _Q_u_o_t_i_n_g below).   Each  single
                     occurrence of an IIFFSS character in the string to be split,
                     that is not in the _i_s_s_p_a_c_e character class, and any adja-
                     cent  characters in IIFFSS that are in the _i_s_s_p_a_c_e character
                     class, delimit a field.  One or more  characters  in  IIFFSS
                     that  belong  to  the  _i_s_s_p_a_c_e character class, delimit a
                     field.   In  addition,  if  the  same  _i_s_s_p_a_c_e  character
                     appears  consecutively  inside  IIFFSS,  this  character  is
                     treated as if it were not in the _i_s_s_p_a_c_e class,  so  that
                     if  IIFFSS consists of two ttaabb characters, then two adjacent
                     ttaabb characters delimit a null field.
              JJOOBBMMAAXX This variable defines the maximum  number  running  back-
                     ground  jobs  that can run at a time.  When this limit is
                     reached, the shell will wait for a job to complete before
                     staring a new job.
              LLAANNGG   This variable determines the locale category for any cat-
                     egory not specifically selected with a variable  starting
                     with LLCC__ or LLAANNGG.
              LLCC__AALLLL This  variable  overrides  the value of the LLAANNGG variable
                     and any other LLCC__ variable.
              LLCC__CCOOLLLLAATTEE
                     This variable determines the locale category for  charac-
                     ter collation information.
              LLCC__CCTTYYPPEE
                     This  variable determines the locale category for charac-
                     ter handling  functions.   It  determines  the  character
                     classes  for  pattern  matching (see _F_i_l_e _N_a_m_e _G_e_n_e_r_a_t_i_o_n
                     below).
              LLCC__NNUUMMEERRIICC
                     This variable determines the locale category for the dec-
                     imal point character.
              LLIINNEESS  If  this  variable is set, the value is used to determine
                     the column length  for  printing  sseelleecctt  lists.   Select
                     lists  will  print  vertically  until about two-thirds of
                     LLIINNEESS lines are filled.
              MMAAIILL   If this variable is set to the name of a  mail  file  _a_n_d
                     the  MMAAIILLPPAATTHH variable is not set, then the shell informs
                     the user of arrival of mail in the specified file.
              MMAAIILLCCHHEECCKK
                     This variable specifies how often (in seconds) the  shell
                     will check for changes in the modification time of any of
                     the files specified by the MMAAIILLPPAATTHH  or  MMAAIILL  variables.
                     The  default  value  is  600  seconds.  When the time has
                     elapsed the shell will  check  before  issuing  the  next
                     prompt.
              MMAAIILLPPAATTHH
                     A  colon  (  ::  )  separated list of file names.  If this
                     variable is set, then the shell informs the user  of  any
                     modifications  to  the specified files that have occurred
                     within the last MMAAIILLCCHHEECCKK seconds.  Each file name can be
                     followed by a ??  and a message that will be printed.  The
                     message will undergo parameter expansion, command substi-
                     tution,  and arithmetic substitution with the variable $$__
                     defined as the name of the file that  has  changed.   The
                     default message is _y_o_u _h_a_v_e _m_a_i_l _i_n _$___.
              PPAATTHH   The  search path for commands (see _E_x_e_c_u_t_i_o_n below).  The
                     user may not change PPAATTHH if executing under rrkksshh  (except
                     in ..pprrooffiillee))..
              PPSS11    The  value  of  this  variable  is expanded for parameter
                     expansion, command substitution, and arithmetic substitu-
                     tion to define the primary prompt string which by default
                     is ‘‘$$’’.  The character !!  in the primary prompt  string
                     is  replaced  by the _c_o_m_m_a_n_d number (see _C_o_m_m_a_n_d _R_e_-_e_n_t_r_y
                     below).  Two successive occurrences of !!  will produce  a
                     single !!  when the prompt string is printed.
              PPSS22    Secondary prompt string, by default ‘‘>> ’’.
              PPSS33    Selection  prompt  string  used  within a sseelleecctt loop, by
                     default ‘‘##?? ’’.
              PPSS44    The value of this  variable  is  expanded  for  parameter
                     evaluation,  command substitution, and arithmetic substi-
                     tution and precedes each line of an execution trace.   By
                     default,  PPSS44  is ‘‘++ ’’.  In addition when PPSS44 is unset,
                     the execution trace prompt is also ‘‘++ ’’.
              SSHHEELLLL  The pathname of the _s_h_e_l_l is kept in the environment.  At
                     invocation,  if  the  basename  of  this variable is rrsshh,
                     rrkksshh, or kkrrsshh, then the shell becomes restricted.  If  it
                     is  ppffsshh or ppffkksshh, then the shell becomes a profile shell
                     (see _p_f_e_x_e_c(1)).
              TTIIMMEEFFOORRMMAATT
                     The value of this parameter is used as  a  format  string
                     specifying  how the timing information for pipelines pre-
                     fixed with the ttiimmee reserved word  should  be  displayed.
                     The  %%  character  introduces  a  format sequence that is
                     expanded to a time value or other information.  The  for-
                     mat sequences and their meanings are as follows.
                     %%%%        A literal %%.
                     %%[[_p]][[ll]]RR  The elapsed time in seconds.
                     %%[[_p]][[ll]]UU  The number of CPU seconds spent in user mode.
                     %%[[_p]][[ll]]SS  The number of CPU seconds spent in system mode.
                     %%PP        The CPU percentage, computed as (U + S) / R.

                     The brackets denote optional portions.  The optional _p is
                     a  digit  specifying  the  _p_r_e_c_i_s_i_o_n, the number of frac-
                     tional digits after a decimal point.  A value of 0 causes
                     no decimal point or fraction to be output.  At most three
                     places after the decimal point can be  displayed;  values
                     of _p greater than 3 are treated as 3.  If _p is not speci-
                     fied, the value 3 is used.

                     The optional ll specifies a longer format, including hours
                     if  greater  than  zero, minutes, and seconds of the form
                     _H_Hh_M_Mm_S_S._F_Fs.  The value of _p determines whether  or  not
                     the fraction is included.

                     All  other  characters  are  output  without change and a
                     trailing newline is added.  If unset, the default  value,
                     $$’’\\nnrreeaall\\tt%%22llRR\\nnuusseerr\\tt%%22llUU\\nnssyyss%%22llSS’’,  is  used.   If the
                     value is null, no timing information is displayed.

              TTMMOOUUTT  If set to a value greater than zero, TTMMOOUUTT  will  be  the
                     default timeout value for the rreeaadd built-in command.  The
                     sseelleecctt compound command terminates  after  TTMMOOUUTT  seconds
                     when input is from a terminal.  Otherwise, the shell will
                     terminate if a line is not entered within the  prescribed
                     number  of  seconds while reading from a terminal.  (Note
                     that the shell can be compiled with a maximum  bound  for
                     this value which cannot be exceeded.)

              VVIISSUUAALL If  the  value  of  this  variable  matches  the  pattern
                     _*_[_V_v_]_[_I_i_]_*, then the vvii option (see Special  Command  sseett
                     below)  is  turned  on.  If the value matches the pattern
                     _*_g_m_a_c_s_* _, the ggmmaaccss option is turned on.   If  the  value
                     matches the pattern _*_m_a_c_s_*, then the eemmaaccss option will be
                     turned on.  The value of VVIISSUUAALL overrides  the  value  of
                     EEDDIITTOORR..

       The  shell gives default values to PPAATTHH, PPSS11, PPSS22, PPSS33, PPSS44, MMAAIILLCCHHEECCKK,
       FFCCEEDDIITT, TTMMOOUUTT and IIFFSS, while HHOOMMEE, SSHHEELLLL, EENNVV, and MMAAIILL are not set  at
       all  by  the shell (although HHOOMMEE _i_s set by _l_o_g_i_n(1)).  On some systems
       MMAAIILL and SSHHEELLLL are also set by _l_o_g_i_n(1).

   FFiieelldd SSpplliittttiinngg..
       After parameter expansion and command substitution, the results of sub-
       stitutions  are scanned for the field separator characters (those found
       in IIFFSS) and split into distinct fields where such characters are found.
       Explicit  null  fields  (""""  or ′′′′) are retained.  Implicit null fields
       (those resulting from _p_a_r_a_m_e_t_e_r_s that have no values or command substi-
       tutions with no output) are removed.

       If the bbrraacceeeexxppaanndd (--BB) option is set then each of the fields resulting
       from IIFFSS are checked to see if they contain one or more  of  the  brace
       patterns  {{**,,**}},  {{_l_1...._l_2}} , {{_n_1...._n_2}} , {{_n_1...._n_2%% _f_m_t}} , {{_n_1...._n_2 ...._n_3}} ,
       or {{_n_1...._n_2 ...._n_3%%_f_m_t}} , where ** represents any character, _l_1,_l_2 are let-
       ters  and  _n_1,_n_2,_n_3 are signed numbers and _f_m_t is a format specified as
       used by pprriinnttff.  In each case, fields are  created  by  prepending  the
       characters  before  the  {{  and appending the characters after the }} to
       each of the strings generated by the characters between the  {{  and  }}.
       The  resulting  fields  are  checked to see if they have any brace pat-
       terns.

       In the first form, a field is created for each string between {{ and  ,,,
       between  ,, and ,,, and between ,, and }}.  The string represented by ** can
       contain embedded matching {{ and }} without quoting.  Otherwise,  each  {{
       and }} with ** must be quoted.

       In  the  seconds form, _l_1 and _l_2 must both be either upper case or both
       be lower case characters in the C locale.  In this case a field is cre-
       ated for each character from _l_1 thru _l_2.

       In  the remaining forms, a field is created for each number starting at
       _n_1 and continuing until it reaches _n_2 incrementing _n_1 by _n_3.  The cases
       where _n_3 is not specified behave as if _n_3 where 11 if _n_1<<==_n_2 and --11 oth-
       erwise.  If forms which specify %%_f_m_t any format flags, widths and  pre-
       cisions  can  be  specified  and  _f_m_t  can end in any of the specifiers
       ccddiioouuxxXX.  For  example,  {{aa,,zz}}{{11....55....33%%0022dd}}{{bb....cc}}xx  expands  to  the  8
       fields, aa0011bbxx, aa0011ccxx, aa0044bbxx, aa0044ccxx, zz0011bbxx, zz0011ccxx, zz0044bbxx and zz44ccxx.

   FFiillee NNaammee GGeenneerraattiioonn..
       Following  splitting, each field is scanned for the characters ∗∗, ??, ((,
       and [[ unless the --ff option has been set.  If one  of  these  characters
       appears, then the word is regarded as a _p_a_t_t_e_r_n.  Each file name compo-
       nent that contains any pattern character is  replaced  with  a  lexico-
       graphically  sorted  set  of  names  that matches the pattern from that
       directory.  If no file name is found that  matches  the  pattern,  then
       that  component of the filename is left unchanged unless the pattern is
       prefixed with ∼∼((NN)) in which case it is removed as described below.   If
       FFIIGGNNOORREE  is set, then each file name component that matches the pattern
       defined by the value of FFIIGGNNOORREE is ignored when generating the matching
       filenames.   The  names ..  and ....  are also ignored.  If FFIIGGNNOORREE is not
       set, the character ..  at the start of each file name component will  be
       ignored unless the first character of the pattern corresponding to this
       component is the character ..  itself.  Note, that  for  other  uses  of
       pattern matching the // and ..  are not treated specially.

              ∗∗      Matches any string, including the null string.  When used
                     for filename expansion, if the gglloobbssttaarr option is on, two
                     adjacent  ∗∗’s  by itself will match all files and zero or
                     more directories and subdirectories.  If followed by a  //
                     then only directories and subdirectories will match.
              ??      Matches any single character.
              [[...]]  Matches  any  one  of the enclosed characters.  A pair of
                     characters separated by -- matches any character lexically
                     between the pair, inclusive.  If the first character fol-
                     lowing the opening [[ is  a  !!   then  any  character  not
                     enclosed  is matched.  A -- can be included in the charac-
                     ter set by putting it as the first or last character.
                     Within [[ and ]], character classes can be  specified  with
                     the  syntax [[::_c_l_a_s_s::]] where class is one of the following
                     classes defined in the ANSI-C standard: (Note  that  wwoorrdd
                     is equivalent to aallnnuumm plus the character __).
              aallnnuumm  aallpphhaa  bbllaannkk  ccnnttrrll  ddiiggiitt  ggrraapphh lloowweerr pprriinntt ppuunncctt ssppaaccee
              uuppppeerr wwoorrdd xxddiiggiitt
              Within [[ and ]], an equivalence class can be specified  with  the
              syntax  [[==_c==]] which matches all characters with the same primary
              collation weight (as defined by the current locale) as the char-
              acter _c.
              Within [[ and ]], [[.._s_y_m_b_o_l..]]  matches the collating symbol _s_y_m_b_o_l.
       A _p_a_t_t_e_r_n_-_l_i_s_t is a list of one or more patterns  separated  from  each
       other  with  a && or ││.  A && signifies that all patterns must be matched
       whereas ││ requires that only one pattern be  matched.   Composite  pat-
       terns can be formed with one or more of the following sub-patterns:
              ??((_p_a_t_t_e_r_n_-_l_i_s_t))
                     Optionally matches any one of the given patterns.
              **((_p_a_t_t_e_r_n_-_l_i_s_t))
                     Matches zero or more occurrences of the given patterns.
              ++((_p_a_t_t_e_r_n_-_l_i_s_t))
                     Matches one or more occurrences of the given patterns.
              {{_n}}(_p_a_t_t_e_r_n_-_l_i_s_t))
                     Matches _n occurrences of the given patterns.
              {{_m,,_n}}(_p_a_t_t_e_r_n_-_l_i_s_t))
                     Matches  from  _m  to _n occurrences of the given patterns.
                     If _m is omitted, 00 will be used.   If  _n  is  omitted  at
                     least _m occurrences will be matched.
              @@((_p_a_t_t_e_r_n_-_l_i_s_t))
                     Matches exactly one of the given patterns.
              !!((_p_a_t_t_e_r_n_-_l_i_s_t))
                     Matches anything except one of the given patterns.
       By  default, each pattern, or sub-pattern will match the longest string
       possible consistent with generating the longest overall match.  If more
       than  one  match is possible, the one starting closest to the beginning
       of the string will be chosen.   However, for each of the above compound
       patterns  a  --  can be inserted in front of the (( to cause the shortest
       match to the specified _p_a_t_t_e_r_n_-_l_i_s_t to be used.

       When _p_a_t_t_e_r_n_-_l_i_s_t is contained within parentheses, the backslash  char-
       acter  \\ is treated specially even when inside a character class.   All
       ANSI-C character escapes are recognized and match the specified charac-
       ter.  In addition the following escape sequences are recognized:
              \\dd     Matches any character in the ddiiggiitt class.
              \\DD     Matches any character not in the ddiiggiitt class.
              \\ss     Matches any character in the ssppaaccee class.
              \\SS     Matches any character not in the ssppaaccee class.
              \\ww     Matches any character in the wwoorrdd class.
              \\WW     Matches any character not in the wwoorrdd class.

       A  pattern  of the form %%((_p_a_t_t_e_r_n_-_p_a_i_r(s))) is a sub-pattern that can be
       used to match nested character expressions.  Each _p_a_t_t_e_r_n_-_p_a_i_r is a two
       character sequence which cannot contain && or ││.  The first _p_a_t_t_e_r_n_-_p_a_i_r
       specifies the starting and ending characters for the match.  Each  sub-
       sequent  _p_a_t_t_e_r_n_-_p_a_i_r represents the beginning and ending characters of
       a nested group that will be skipped over  when  counting  starting  and
       ending  character  matches.  The behavior is unspecified when the first
       character of a _p_a_t_t_e_r_n_-_p_a_i_r is alpha-numeric except for the following:
              DD      Causes the ending character to terminate the  search  for
                     this pattern without finding a match.
              EE      Causes  the  ending  character  to  be  interpreted as an
                     escape character.
              LL      Causes the ending character to be interpreted as a  quote
                     character causing all characters to be ignored when look-
                     ing for a match.
              QQ      Causes the ending character to be interpreted as a  quote
                     character  causing  all  characters other than any escape
                     character to be ignored when looking for a match.
       Thus, %%(({{}}QQ""EE\\)), matches characters starting at {{ until the matching  }}
       is  found not counting any {{ or }} that is inside a double quoted string
       or preceded by the escape character \\.  Without  the  {{}}  this  pattern
       matches any C language string.

       Each  sub-pattern in a composite pattern is numbered, starting at 1, by
       the location of the (( within the pattern.  The sequence \\_n, where _n  is
       a  single  digit  and \\_n comes after the _n-th. sub-pattern, matches the
       same string as the sub-pattern itself.

       Finally a pattern can contain sub-patterns of the  form  ∼∼((_o_p_t_i_o_n_s::_p_a_t_-
       _t_e_r_n_-_l_i_s_t)),  where  either  _o_p_t_i_o_n_s  or  ::_p_a_t_t_e_r_n_-_l_i_s_t  can be omitted.
       Unlike the other compound patterns, these sub-patterns are not  counted
       in the numbered sub-patterns.  If _o_p_t_i_o_n_s is present, it can consist of
       one or more of the following:
              ++      Enable the following options.  This is the default.
              --      Disable the following options.
              EE      The  remainder  of  the  pattern  uses  extended  regular
                     expression syntax like the _e_g_r_e_p(1) command.
              FF      The  remainder  of  the  pattern uses _f_g_r_e_p(1) expression
                     syntax.
              GG      The remainder of the pattern uses basic  regular  expres-
                     sion syntax like the _g_r_e_p(1) command.
              KK      The  remainder  of the pattern uses shell pattern syntax.
                     This is the default.
              NN      This is ignored.  However, when it is  the  first  letter
                     and  is  used  with  file name generation, and no matches
                     occur, the file pattern expands to the empty string.
              ii      Treat the match as case insensitive.
              gg      File the longest match (greedy).  This is the default.
              ll      Left anchor the pattern.  This is the default for KK style
                     patterns.
              rr      Right  anchor  the  pattern.   This  is the default for KK
                     style patterns.
       If both _o_p_t_i_o_n_s and ::_p_a_t_t_e_r_n_-_l_i_s_t are specified, then the options apply
       only to  _p_a_t_t_e_r_n_-_l_i_s_t.  Otherwise, these options remain in effect until
       they are disabled by a subsequent ∼∼((_._._.)) or at the end of the  sub-pat-
       tern containing ∼∼((_._._.)).

   QQuuoottiinngg..
       Each of the _m_e_t_a_c_h_a_r_a_c_t_e_r_s listed earlier (see _D_e_f_i_n_i_t_i_o_n_s above) has a
       special meaning to the shell and causes termination of  a  word  unless
       quoted.   A character may be _q_u_o_t_e_d (i.e., made to stand for itself) by
       preceding it with a \\.  The pair \\nneeww--lliinnee is removed.  All  characters
       enclosed between a pair of single quote marks (′′′′) that is not preceded
       by a $$ are quoted.  A single quote  cannot  appear  within  the  single
       quotes.   A single quoted string preceded by an unquoted $$ is processed
       as an ANSI-C string except for the following:
       \\00     Causes the remainder of the string to be ignored.
       \\EE     Equivalent to the escape character (ascii 003333),
       \\ee     Equivalent to the escape character (ascii 003333),
       \\cc_x    Expands to the character control-_x.
       \\CC[[.._n_a_m_e..]]
              Expands to the collating element _n_a_m_e.

       Inside double quote marks  (""""),  parameter  and  command  substitution
       occur  and  \\  quotes the characters \\, ``, "", and $$.  A $$ in front of a
       double quoted string will be ignored in the "C" or "POSIX" locale,  and
       may  cause the string to be replaced by a locale specific string other-
       wise.  The meaning of $$∗∗ and $$@@ is identical when not  quoted  or  when
       used  as  a variable assignment value or as a file name.  However, when
       used as a command argument, ""$$∗∗"" is equivalent to ""$$11_d$$22_d..."", where  _d
       is  the first character of the IIFFSS variable, whereas ""$$@@"" is equivalent
       to ""$$11"" ""$$22"" ....  Inside grave quote marks (````), \\ quotes the  charac-
       ters \\, ``, and $$.  If the grave quotes occur within double quotes, then
       \\ also quotes the character "".

       The special meaning of reserved words or  aliases  can  be  removed  by
       quoting  any  character of the reserved word.  The recognition of func-
       tion names or built-in command names listed below cannot be altered  by
       quoting them.

   AArriitthhmmeettiicc EEvvaalluuaattiioonn..
       The  shell  performs arithmetic evaluation for arithmetic substitution,
       to evaluate an arithmetic command, to evaluate an  indexed  array  sub-
       script,  and  to  evaluate arguments to the built-in commands sshhiifftt and
       lleett.  Evaluations are performed using double precision  floating  point
       arithmetic  or  long  double  precision floating point for systems that
       provide this data type.  Floating point  constants  follow  the  ANSI-C
       programming  language  floating  point  conventions.  Integer constants
       follow the ANSI-C programming  language  integer  constant  conventions
       although  only single byte character constants are recognized and char-
       acter casts are not recognized.  In addition constants can  be  of  the
       form [_b_a_s_e##]_n where _b_a_s_e is a decimal number between two and sixty-four
       representing the arithmetic base and _n is a number in that  base.   The
       digits  above  9  are  represented by the lower case letters, the upper
       case letters, @@, and __ respectively.  For bases less than or  equal  to
       36, upper and lower case characters can be used interchangeably.

       An arithmetic expression uses the same syntax, precedence, and associa-
       tivity of expression as the C language.  All the C  language  operators
       that  apply to floating point quantities can be used.  In addition, the
       operator **** can be used for exponentiation.  It has  higher  precedence
       than  multiplication  and  is  left associative.  In addition, when the
       value of an arithmetic variable or sub-expression can be represented as
       a  long  integer,  all  C language integer arithmetic operations can be
       performed.  Variables can be referenced by name  within  an  arithmetic
       expression  without using the parameter expansion syntax.  When a vari-
       able is referenced, its value is evaluated as an arithmetic expression.

       Any  of  the  following  math  library functions that are in the C math
       library can be used within an arithmetic expression:

       aabbss aaccooss aaccoosshh aassiinn aassiinnhh aattaann aattaann22 aattaannhh ccbbrrtt ccooppyyssiiggnn ccooss  ccoosshh  eerrff
       eerrffcc  eexxpp  eexxpp22  eexxppmm11 ffaabbss ffddiimm ffiinniittee fflloooorr ffmmaa ffmmaaxx ffmmoodd hhyyppoott iillooggbb
       iinntt iissiinnff iissnnaann jj00 jj11 jjnn llggaammmmaa lloogg lloogg22 llooggbb nneeaarrbbyyiinntt nneexxttaafftteerr nneexxtt--
       ttoowwaarrdd  ppooww rreemmaaiinnddeerr rriinntt rroouunndd ssiinn ssiinnhh ssqqrrtt ttaann ttaannhh ttggaammmmaa ttrruunncc yy00
       yy11 yynn

       An internal representation of a _v_a_r_i_a_b_l_e as a double precision floating
       point can be specified with the --EE [_n], --FF [_n], or --XX [_n] option of the
       ttyyppeesseett special built-in command.  The --EE option causes  the  expansion
       of  the  value  to  be represented using scientific notation when it is
       expanded.  The optional option argument _n defines the number of signif-
       icant figures.  The --FF option causes the expansion to be represented as
       a floating decimal number when it is expanded.  The --XX option cause the
       expansion  to  be  represented using the %%aa format defined by ISO C-99.
       The optional option argument _n defines the number of places  after  the
       decimal (or radix) point in this case.

       An  internal integer representation of a _v_a_r_i_a_b_l_e can be specified with
       the --ii [_n]  option  of  the  ttyyppeesseett  special  built-in  command.   The
       optional option argument _n specifies an arithmetic base to be used when
       expanding the variable.  If you do not specify an arithmetic base, base
       10 will be used.

       Arithmetic evaluation is performed on the value of each assignment to a
       variable with the --EE, --FF, --XX, or --ii attribute.   Assigning  a  floating
       point  number  to  a variable whose type is an integer causes the frac-
       tional part to be truncated.


   PPrroommppttiinngg..
       When used interactively, the shell prompts with the value of PPSS11  after
       expanding  it for parameter expansion, command substitution, and arith-
       metic substitution, before reading a command.  In addition, each single
       !!   in the prompt is replaced by the command number.  A !!!!  is required
       to place !!  in the prompt.  If at any time a new-line is typed and fur-
       ther  input  is needed to complete a command, then the secondary prompt
       (i.e., the value of PPSS22) is issued.

   CCoonnddiittiioonnaall EExxpprreessssiioonnss..
       A _c_o_n_d_i_t_i_o_n_a_l _e_x_p_r_e_s_s_i_o_n is used with the [[[[ compound command  to  test
       attributes  of  files and to compare strings.  Field splitting and file
       name generation are not performed on the words between [[[[ and ]]]].  Each
       expression  can  be constructed from one or more of the following unary
       or binary expressions:
       _s_t_r_i_n_g True, if _s_t_r_i_n_g is not null.
       --aa _f_i_l_e
              Same as --ee below.  This is obsolete.
       --bb _f_i_l_e
              True, if _f_i_l_e exists and is a block special file.
       --cc _f_i_l_e
              True, if _f_i_l_e exists and is a character special file.
       --dd _f_i_l_e
              True, if _f_i_l_e exists and is a directory.
       --ee _f_i_l_e
              True, if _f_i_l_e exists.
       --ff _f_i_l_e
              True, if _f_i_l_e exists and is an ordinary file.
       --gg _f_i_l_e
              True, if _f_i_l_e exists and it has its setgid bit set.
       --kk _f_i_l_e
              True, if _f_i_l_e exists and it has its sticky bit set.
       --nn _s_t_r_i_n_g
              True, if length of _s_t_r_i_n_g is non-zero.
       --oo ??_o_p_t_i_o_n
              True, if option named _o_p_t_i_o_n is a valid option name.
       --oo _o_p_t_i_o_n
              True, if option named _o_p_t_i_o_n is on.
       --pp _f_i_l_e
              True, if _f_i_l_e exists and is a fifo special file or a pipe.
       --rr _f_i_l_e
              True, if _f_i_l_e exists and is readable by current process.
       --ss _f_i_l_e
              True, if _f_i_l_e exists and has size greater than zero.
       --tt _f_i_l_d_e_s
              True, if file descriptor number _f_i_l_d_e_s is  open  and  associated
              with a terminal device.
       --uu _f_i_l_e
              True, if _f_i_l_e exists and it has its setuid bit set.
       --ww _f_i_l_e
              True, if _f_i_l_e exists and is writable by current process.
       --xx _f_i_l_e
              True,  if  _f_i_l_e exists and is executable by current process.  If
              _f_i_l_e exists and is a directory, then true if the current process
              has permission to search in the directory.
       --zz _s_t_r_i_n_g
              True, if length of _s_t_r_i_n_g is zero.
       --LL _f_i_l_e
              True, if _f_i_l_e exists and is a symbolic link.
       --hh _f_i_l_e
              True, if _f_i_l_e exists and is a symbolic link.
       --NN _f_i_l_e
              True,  if  _f_i_l_e exists and the modification time is greater than
              the last access time.
       --OO _f_i_l_e
              True, if _f_i_l_e exists and is owned by the effective  user  id  of
              this process.
       --GG _f_i_l_e
              True,  if  _f_i_l_e exists and its group matches the effective group
              id of this process.
       --SS _f_i_l_e
              True, if _f_i_l_e exists and is a socket.
       _f_i_l_e_1 --nntt _f_i_l_e_2
              True, if _f_i_l_e_1 exists and _f_i_l_e_2 does not, or _f_i_l_e_1 is newer than
              _f_i_l_e_2.
       _f_i_l_e_1 --oott _f_i_l_e_2
              True, if _f_i_l_e_2 exists and _f_i_l_e_1 does not, or _f_i_l_e_1 is older than
              _f_i_l_e_2.
       _f_i_l_e_1 --eeff _f_i_l_e_2
              True, if _f_i_l_e_1 and _f_i_l_e_2 exist and refer to the same file.
       _s_t_r_i_n_g ==== _p_a_t_t_e_r_n
              True, if _s_t_r_i_n_g matches _p_a_t_t_e_r_n.  Any part  of  _p_a_t_t_e_r_n  can  be
              quoted to cause it to be matched as a string.  With a successful
              match to a pattern, the ..sshh..mmaattcchh array  variable  will  contain
              the match and sub-pattern matches.
       _s_t_r_i_n_g == _p_a_t_t_e_r_n
              Same as ==== above, but is obsolete.
       _s_t_r_i_n_g !!== _p_a_t_t_e_r_n
              True, if _s_t_r_i_n_g does not match _p_a_t_t_e_r_n.  When the _s_t_r_i_n_g matches
              the _p_a_t_t_e_r_n the ..sshh..mmaattcchh array variable will contain the  match
              and sub-pattern matches.
       _s_t_r_i_n_g ==∼∼ _e_r_e
              True  if  _s_t_r_i_n_g  matches  the  pattern  ∼∼((EE))_e_r_e where _e_r_e is an
              extended regular expression.
       _s_t_r_i_n_g_1 << _s_t_r_i_n_g_2
              True, if _s_t_r_i_n_g_1 comes before _s_t_r_i_n_g_2 based on  ASCII  value  of
              their characters.
       _s_t_r_i_n_g_1 >> _s_t_r_i_n_g_2
              True,  if  _s_t_r_i_n_g_1  comes  after _s_t_r_i_n_g_2 based on ASCII value of
              their characters.
       The following obsolete arithmetic comparisons are also permitted:
       _e_x_p_1 --eeqq _e_x_p_2
              True, if _e_x_p_1 is equal to _e_x_p_2.
       _e_x_p_1 --nnee _e_x_p_2
              True, if _e_x_p_1 is not equal to _e_x_p_2.
       _e_x_p_1 --lltt _e_x_p_2
              True, if _e_x_p_1 is less than _e_x_p_2.
       _e_x_p_1 --ggtt _e_x_p_2
              True, if _e_x_p_1 is greater than _e_x_p_2.
       _e_x_p_1 --llee _e_x_p_2
              True, if _e_x_p_1 is less than or equal to _e_x_p_2.
       _e_x_p_1 --ggee _e_x_p_2
              True, if _e_x_p_1 is greater than or equal to _e_x_p_2.

       In each of the above expressions, if _f_i_l_e is  of  the  form  //ddeevv//ffdd//_n,
       where  _n is an integer, then the test is applied to the open file whose
       descriptor number is _n.

       A compound expression can be constructed from these primitives by using
       any of the following, listed in decreasing order of precedence.
       ((_e_x_p_r_e_s_s_i_o_n))
              True, if _e_x_p_r_e_s_s_i_o_n is true.  Used to group expressions.
       !! _e_x_p_r_e_s_s_i_o_n
              True if _e_x_p_r_e_s_s_i_o_n is false.
       _e_x_p_r_e_s_s_i_o_n_1 &&&& _e_x_p_r_e_s_s_i_o_n_2
              True, if _e_x_p_r_e_s_s_i_o_n_1 and _e_x_p_r_e_s_s_i_o_n_2 are both true.
       _e_x_p_r_e_s_s_i_o_n_1 ││││ _e_x_p_r_e_s_s_i_o_n_2
              True, if either _e_x_p_r_e_s_s_i_o_n_1 or _e_x_p_r_e_s_s_i_o_n_2 is true.

   IInnppuutt//OOuuttppuutt..
       Before  a  command  is executed, its input and output may be redirected
       using a special notation interpreted by the shell.  The  following  may
       appear  anywhere in a simple-command or may precede or follow a _c_o_m_m_a_n_d
       and are _n_o_t passed on to the invoked  command.   Command  substitution,
       parameter  expansion,  and arithmetic substitution occur before _w_o_r_d or
       _d_i_g_i_t is used except as noted below.  File name generation occurs  only
       if  the  shell  is  interactive  and the pattern matches a single file.
       Field splitting is not performed.

       In each  of  the  following  redirections,  if  _f_i_l_e  is  of  the  form
       //ddeevv//ssccttpp//_h_o_s_t//_p_o_r_t,  //ddeevv//ttccpp//_h_o_s_t//_p_o_r_t,  or //ddeevv//uuddpp//_h_o_s_t//_p_o_r_t, where
       _h_o_s_t is a hostname or host address, and _p_o_r_t is a service given by name
       or an integer port number, then the redirection attempts to make a ttccpp,
       ssccttpp or uuddpp connection to the corresponding socket.

       No intervening space is allowed between the characters  of  redirection
       operators.

       <<_w_o_r_d         Use file _w_o_r_d as standard input (file descriptor 0).

       >>_w_o_r_d         Use file _w_o_r_d as standard output (file descriptor 1).  If
                     the file does not exist then it is created.  If the  file
                     exists,  and  the  nnoocclloobbbbeerr option is on, this causes an
                     error; otherwise, it is truncated to zero length.

       >>||_w_o_r_d        Sames as  >>,  except  that  it  overrides  the  nnoocclloobbbbeerr
                     option.

       >>;;_w_o_r_d        Write  output  to  a temporary file.  If the command com-
                     pletes successfully rename it to _w_o_r_d, otherwise,  delete
                     the  temporary  file.   >>;;_w_o_r_d  cannot  be  used with the
                     _e_x_e_c(2).  built-in.

       >>>>_w_o_r_d        Use file _w_o_r_d as standard output.  If  the  file  exists,
                     then  output  is  appended to it (by first seeking to the
                     end-of-file); otherwise, the file is created.

       <<>>_w_o_r_d        Open file _w_o_r_d for reading and writing as  standard  out-
                     put.

       <<>>;;_w_o_r_d       The  same  as <<>>_w_o_r_d except that if the command completes
                     successfully, _w_o_r_d is truncated to the offset at  command
                     completion.   <<>>;;_w_o_r_d  cannot  be  used with the _e_x_e_c(2).
                     built-in.

       <<<<[--]_w_o_r_d     The shell input is read up to a line that is the same  as
                     _w_o_r_d after any quoting has been removed, or to an end-of-
                     file.  No parameter substitution,  command  substitution,
                     arithmetic  substitution  or file name generation is per-
                     formed on _w_o_r_d.  The resulting document, called  a  _h_e_r_e_-
                     _d_o_c_u_m_e_n_t,  becomes  the standard input.  If any character
                     of _w_o_r_d is quoted, then no interpretation is placed  upon
                     the  characters  of  the  document;  otherwise, parameter
                     expansion, command substitution, and arithmetic substitu-
                     tion  occur,  \\nneeww--lliinnee is ignored, and \\ must be used to
                     quote the characters \\, $$, ``.  If -- is  appended  to  <<<<,
                     then all leading tabs are stripped from _w_o_r_d and from the
                     document.  If ## is appended to <<<<,  then  leading  spaces
                     and tabs will be stripped off the first line of the docu-
                     ment and up to an equivalent indentation will be stripped
                     from  the  remaining  lines and from _w_o_r_d.  A tab stop is
                     assumed to occur at every 8 columns for the  purposes  of
                     determining the indentation.

       <<<<<<_w_o_r_d       A  short  form of here document in which _w_o_r_d becomes the
                     contents of the here-document after any parameter  expan-
                     sion,  command  substitution, and arithmetic substitution
                     occur.

       <<&&_d_i_g_i_t       The standard input is  duplicated  from  file  descriptor
                     _d_i_g_i_t  (see  _d_u_p(2)).   Similarly for the standard output
                     using >>&&_d_i_g_i_t.

       <<&&_d_i_g_i_t--      The file descriptor given by _d_i_g_i_t is moved  to  standard
                     input.  Similarly for the standard output using >>&&_d_i_g_i_t--.

       <<&&--           The standard input is closed.  Similarly for the standard
                     output using >>&&--.

       <<&&pp           The input from the co-process is moved to standard input.

       >>&&pp           The output to the co-process is moved to standard output.

       <<##((((_e_x_p_r))))    Evaluate  arithmetic  expression  _e_x_p_r  and position file
                     descriptor 0 to the resulting value bytes from the  start
                     of  the  file.  The variables CCUURR and EEOOFF evaluate to the
                     current offset and end-of-file offset  respectively  when
                     evaluating _e_x_p_r_.

       >>##((((_o_f_f_s_e_t))))  The same as <<## except applies to file descriptor 1.

       <<##_p_a_t_t_e_r_n     Seeks  forward to the beginning of the next line contain-
                     ing _p_a_t_t_e_r_n.

       <<####_p_a_t_t_e_r_n    The same as <<## except that the portion of the  file  that
                     is skipped is copied to standard output.

       If  one of the above is preceded by a digit, with no intervening space,
       then the file descriptor number referred to is that  specified  by  the
       digit (instead of the default 0 or 1).  If one of the above, other than
       >>&&-- and the  >>##  and  <<##  forms,  is  preceded  by  {{_v_a_r_n_a_m_e}}  with  no
       intervening  space, then a file descriptor number > 10 will be selected
       by the shell and stored in the variable _v_a_r_n_a_m_e.  If >>&&-- or the any  of
       the  >>##  and  <<##  forms  is  preceded by {{_v_a_r_n_a_m_e}} the value of _v_a_r_n_a_m_e
       defines the file descriptor to close or position.  For example:

              ...... 22>>&&11

       means file descriptor 2 is to be opened for writing as a  duplicate  of
       file descriptor 1 and

              eexxeecc {{nn}}<<ffiillee

       means  open  file  named ffiillee for reading and store the file descriptor
       number in variable nn.

       The order in which redirections  are  specified  is  significant.   The
       shell  evaluates  each  redirection  in  terms of the (_f_i_l_e _d_e_s_c_r_i_p_t_o_r,
       _f_i_l_e) association at the time of evaluation.  For example:

              ...... 11>>_f_n_a_m_e 22>>&&11

       first associates file descriptor 1 with file _f_n_a_m_e.  It then associates
       file descriptor 2 with the file associated with file descriptor 1 (i.e.
       _f_n_a_m_e).  If the order of redirections were reversed, file descriptor  2
       would  be  associated with the terminal (assuming file descriptor 1 had
       been) and then file descriptor 1 would be associated with file _f_n_a_m_e.

       If a command is followed by && and job control is not active,  then  the
       default  standard  input  for  the command is the empty file //ddeevv//nnuullll.
       Otherwise, the environment for the execution of a command contains  the
       file  descriptors  of  the  invoking  shell as modified by input/output
       specifications.

   EEnnvviirroonnmmeenntt..
       The _e_n_v_i_r_o_n_m_e_n_t (see _e_n_v_i_r_o_n(7)) is a list of name-value pairs that  is
       passed  to  an  executed  program  in the same way as a normal argument
       list.  The names must be  _i_d_e_n_t_i_f_i_e_r_s  and  the  values  are  character
       strings.  The shell interacts with the environment in several ways.  On
       invocation, the shell scans the environment and creates a variable  for
       each  name  found, giving it the corresponding value and attributes and
       marking it _e_x_p_o_r_t.  Executed commands inherit the environment.  If  the
       user  modifies the values of these variables or creates new ones, using
       the eexxppoorrtt or ttyyppeesseett --xx commands, they become part of the environment.
       The  environment  seen  by any executed command is thus composed of any
       name-value pairs originally inherited by the shell, whose values may be
       modified  by  the current shell, plus any additions which must be noted
       in eexxppoorrtt or ttyyppeesseett --xx commands.

       The environment for any _s_i_m_p_l_e_-_c_o_m_m_a_n_d or function may be augmented  by
       prefixing it with one or more variable assignments.  A variable assign-
       ment argument is a word of the form _i_d_e_n_t_i_f_i_e_r_=_v_a_l_u_e.  Thus:

              TTEERRMM==445500 ccmmdd aarrggss                  and
              ((eexxppoorrtt TTEERRMM;; TTEERRMM==445500;; ccmmdd aarrggss))

       are equivalent (as far as the  above  execution  of  _c_m_d  is  concerned
       except for special built-in commands listed below - those that are pre-
       ceded with a dagger).

       If the obsolete --kk option is set, _a_l_l variable assignment arguments are
       placed  in  the environment, even if they occur after the command name.
       The following first prints aa==bb cc and then cc:

              eecchhoo aa==bb cc
              sseett --kk
              eecchhoo aa==bb cc
       This feature is intended for use with scripts written  for  early  ver-
       sions  of the shell and its use in new scripts is strongly discouraged.
       It is likely to disappear someday.

   FFuunnccttiioonnss..
       For historical reasons, there are two ways  to  define  functions,  the
       _n_a_m_e(())  syntax  and the ffuunnccttiioonn _n_a_m_e syntax, described in the _C_o_m_m_a_n_d_s
       section above.  Shell functions are  read  in  and  stored  internally.
       Alias names are resolved when the function is read.  Functions are exe-
       cuted like commands with the arguments passed as positional parameters.
       (See _E_x_e_c_u_t_i_o_n below.)

       Functions  defined  by the ffuunnccttiioonn _n_a_m_e syntax and called by name exe-
       cute in the same process as the caller and share all files and  present
       working  directory  with  the  caller.   Traps caught by the caller are
       reset to their default action inside the function.   A  trap  condition
       that  is  not  caught or ignored by the function causes the function to
       terminate and the condition to be passed on to the caller.  A  trap  on
       EEXXIITT set inside a function is executed in the environment of the caller
       after the function completes.  Ordinarily, variables are shared between
       the  calling  program  and  the function.  However, the ttyyppeesseett special
       built-in command used within a function defines local  variables  whose
       scope  includes  the current function.  They can be passed to functions
       that they call in the variable assignment list that precedes  the  call
       or  as  arguments  passed  as name references.  Errors within functions
       return control to the caller.

       Functions defined with the _n_a_m_e(()) syntax and functions defined with the
       ffuunnccttiioonn  _n_a_m_e syntax that are invoked with the ..  special built-in are
       executed in the caller’s environment and share all variables and  traps
       with  the  caller.   Errors  within these function executions cause the
       script that contains them to abort.

       The special built-in command rreettuurrnn is used  to  return  from  function
       calls.

       Function  names  can  be listed with the --ff or ++ff option of the ttyyppeesseett
       special built-in command.  The text of functions, when available,  will
       also  be listed with --ff.  Functions can be undefined with the --ff option
       of the uunnsseett special built-in command.

       Ordinarily, functions are unset when the shell executes a shell script.
       Functions  that  need  to be defined across separate invocations of the
       shell should be placed in a directory and  the  FFPPAATTHH  variable  should
       contain  the name of this directory.  They may also be specified in the
       EENNVV file.

   DDiisscciipplliinnee FFuunnccttiioonnss..
       Each variable can have zero or  more  discipline  functions  associated
       with  it.   The  shell  initially understands the discipline names ggeett,
       sseett, aappppeenndd, and uunnsseett but can be added when defining  new  types.   On
       most  systems  others  can  be  added at run time via the C programming
       interface extension provided by the bbuuiillttiinn built-in utility.   If  the
       ggeett  discipline  is  defined for a variable, it is invoked whenever the
       given variable is referenced.  If the variable ..sshh..vvaalluuee is assigned  a
       value  inside  the  discipline  function,  the referenced variable will
       evaluate to this value instead.  If the sseett discipline is defined for a
       variable,  it  is  invoked  whenever  the  given variable is assigned a
       value.  If the aappppeenndd discipline is  defined  for  a  variable,  it  is
       invoked  whenever a value is appended to the given variable.  The vari-
       able ..sshh..vvaalluuee is given the value of the variable before  invoking  the
       discipline,  and  the  variable will be assigned the value of ..sshh..vvaalluuee
       after the discipline completes.  If ..sshh..vvaalluuee is unset inside the  dis-
       cipline,  then  that  value  is  unchanged.  If the uunnsseett discipline is
       defined for a variable, it is invoked whenever the  given  variable  is
       unset.   The  variable  will not be unset unless it is unset explicitly
       from within this discipline function.

       The variable ..sshh..nnaammee contains the name of the variable for  which  the
       discipline  function  is  called, ..sshh..ssuubbssccrriipptt is the subscript of the
       variable, and ..sshh..vvaalluuee will contain the value  being  assigned  inside
       the  sseett  discipline  function.   The  variable __ is a reference to the
       variable including the subscript  if  any.   For  the  sseett  discipline,
       changing  ..sshh..vvaalluuee will change the value that gets assigned.  Finally,
       the expansion $${{_v_a_r.._n_a_m_e}}, when _n_a_m_e is the name of a  discipline,  and
       there is no variable of this name, is equivalent to the command substi-
       tution $${{ _v_a_r.._n_a_m_e;;}}.


   TTyyppee VVaarriiaabblleess..
       Typed variables provide a way to create data structure and objects.   A
       type  can  be  defined either by a shared library, by the eennuumm built-in
       command described below, or by using the new --TT option of  the  ttyyppeesseett
       built-in command.  With the --TT option of ttyyppeesseett, the type name, speci-
       fied as an option argument to --TT,  is  set  with  a  compound  variable
       assignment  that  defines  the  type.   Function definitions can appear
       inside the compound variable assignment  and  these  become  discipline
       functions  for  this  type  and  can  be  invoked  or redefined by each
       instance of the type.  The function name ccrreeaattee is  treated  specially.
       It  is invoked for each instance of the type that is created but is not
       inherited and cannot be redefined for each instance.

       When a type is defined a special  built-in  command  of  that  name  is
       added.   These  built-ins  are declaration commands and follow the same
       expansion rules as all the special built-in commands defined below that
       are  preceded  by  ††.   These commands can subsequently be used inside
       further type definitions.  The man page for these commands can be  gen-
       erated  by  using  the  ----mmaann  option  or  any  of the other ---- options
       described with ggeettooppttss.  The --rr, --aa, --AA, --hh, and --SS options of  ttyyppeesseett
       are permitted with each of these new built-ins.

       An  instance of a type is created by invoking the type name followed by
       one or more instance names.  Each instance of the type  is  initialized
       with  a  copy  of  the  sub-variables except for sub-variables that are
       defined with the --SS option.  Variables defined with the --SS  are  shared
       by  all  instances  of the type.  Each instance can change the value of
       any sub-variable and can also define new discipline  functions  of  the
       same names as those defined by the type definition as well as any stan-
       dard discipline names.  No additional sub-variables can be defined  for
       any instance.

       When defining a type, if the value of a sub-variable is not set and the
       --rr attribute is specified, it causes the sub-variable to be a  required
       sub-variable.   Whenever an instance of a type is created, all required
       sub-variables must be specified.  These sub-variables  become  readonly
       in each instance.

       When  uunnsseett  is  invoked  on  a  sub-variable within a type, and the --rr
       attribute has not been specified for this field, the value is reset  to
       the  default value associative with the type.  Invoking uunnsseett on a type
       instance not contained within another type  deletes  all  sub-variables
       and the variable itself.

       A type definition can be derived from another type definition by defin-
       ing the first sub-variable name as __ and defining its type as the  base
       type.   Any  remaining  definitions will be additions and modifications
       that apply to the new type.  If the new type name is the same  is  that
       of  the base type, the type will be replaced and the original type will
       no longer be accessible.


   JJoobbss..
       If the mmoonniittoorr option of the sseett command is turned on,  an  interactive
       shell associates a _j_o_b with each pipeline.  It keeps a table of current
       jobs, printed by the jjoobbss command, and assigns them small integer  num-
       bers.   When a job is started asynchronously with &&, the shell prints a
       line which looks like:

            [1] 1234

       indicating that the job which was started asynchronously was job number
       1 and had one (top-level) process, whose process id was 1234.

       This  paragraph  and the next require features that are not in all ver-
       sions of UNIX and may not apply.  If you are running a job and wish  to
       do something else you may hit the key ^^ZZ (control-Z) which sends a STOP
       signal to the current job.  The shell will then normally indicate  that
       the  job  has  been  ‘Stopped’, and print another prompt.  You can then
       manipulate the state of this job, putting it in the background with the
       bbgg  command,  or  run some other commands and then eventually bring the
       job back into the foreground with the  foreground  command  ffgg.   A  ^^ZZ
       takes  effect immediately and is like an interrupt in that pending out-
       put and unread input are discarded when it is typed.

       A job being run in the background will stop if it tries  to  read  from
       the  terminal.  Background jobs are normally allowed to produce output,
       but this can be disabled by giving the command ssttttyy ttoossttoopp.  If you set
       this  tty  option, then background jobs will stop when they try to pro-
       duce output like they do when they try to read input.

       There are several ways to refer to jobs in the shell.   A  job  can  be
       referred  to  by  the process id of any process of the job or by one of
       the following:
       %%_n_u_m_b_e_r
              The job with the given number.
       %%_s_t_r_i_n_g
              Any job whose command line begins with _s_t_r_i_n_g.
       %%??_s_t_r_i_n_g
              Any job whose command line contains _s_t_r_i_n_g.
       %%%%     Current job.
       %%++     Equivalent to %%%%.
       %%--     Previous job.

       The shell learns immediately whenever a process changes state.  It nor-
       mally  informs  you  whenever  a job becomes blocked so that no further
       progress is possible, but only just before it prints a prompt.  This is
       done  so  that  it  does  not  otherwise disturb your work.  The nnoottiiffyy
       option of the sseett command causes the shell to print  these  job  change
       messages as soon as they occur.

       When the mmoonniittoorr option is on, each background job that completes trig-
       gers any trap set for CCHHLLDD.

       When you try to leave the shell while jobs are running or stopped,  you
       will  be warned that ‘You have stopped(running) jobs.’  You may use the
       jjoobbss command to see what they are.  If  you  immediately  try  to  exit
       again,  the shell will not warn you a second time, and the stopped jobs
       will be terminated.  When a login shell receives a HUP signal, it sends
       a  HUP  signal  to  each job that has not been disowned with the ddiissoowwnn
       built-in command described below.

   SSiiggnnaallss..
       The INT and QUIT signals for an invoked command are ignored if the com-
       mand is followed by && and the mmoonniittoorr option is not active.  Otherwise,
       signals have the values inherited by the shell from its parent (but see
       also the ttrraapp built-in command below).

   EExxeeccuuttiioonn..
       Each  time  a command is read, the above substitutions are carried out.
       If the command name matches one of the _S_p_e_c_i_a_l _B_u_i_l_t_-_i_n _C_o_m_m_a_n_d_s listed
       below, it is executed within the current shell process.  Next, the com-
       mand name is checked to see if it matches a user defined function.   If
       it  does,  the  positional  parameters  are saved and then reset to the
       arguments of the _f_u_n_c_t_i_o_n call.  A function is  also  executed  in  the
       current shell process.  When the _f_u_n_c_t_i_o_n completes or issues a rreettuurrnn,
       the positional parameter list is restored.  For functions defined  with
       the  ffuunnccttiioonn  _n_a_m_e syntax, any trap set on EEXXIITT within the function is
       executed.  The exit value of a _f_u_n_c_t_i_o_n is the value of the  last  com-
       mand  executed.  If a command name is not a _s_p_e_c_i_a_l _b_u_i_l_t_-_i_n _c_o_m_m_a_n_d or
       a user defined _f_u_n_c_t_i_o_n, but it is one of the built-in commands  listed
       below, it is executed in the current shell process.

       The  shell variable PPAATTHH defines the search path for the directory con-
       taining the command.  Alternative directory names are  separated  by  a
       colon (::).  The default path is equal to ggeettccoonnff PPAATTHH output.  The cur-
       rent directory can be specified by two or more adjacent colons, or by a
       colon  at  the  beginning or end of the path list.  If the command name
       contains a //, then the search path is not used.  Otherwise, each direc-
       tory  in  the path is searched for an executable file of the given name
       that is not a directory.  If found, and if the  shell  determines  that
       there is a built-in version of a command corresponding to a given path-
       name, this built-in is invoked in the current process.  If  found,  and
       this  directory  is  also contained in the value of the FFPPAATTHH variable,
       then this file is loaded into the current shell environment  as  if  it
       were  the argument to the .. command except that only preset aliases are
       expanded, and a function of the given name  is  executed  as  described
       above.   If not found, and the file ..ppaatthhss is found, and this file con-
       tains a line of the form FFPPAATTHH==_p_a_t_h where _p_a_t_h names an existing direc-
       tory,  and  this directory contains a file of the given name, then this
       file is loaded into the current shell environment as  if  it  were  the
       argument  to the .. special built-in command and a function of the given
       name is executed.  Otherwise, if found, a process  is  created  and  an
       attempt is made to execute the command via _e_x_e_c(2).

       When  an  executable  is  found,  the directory where it is found in is
       searched for a file named ..ppaatthhss.  If this file is found  and  it  con-
       tains  a line of the form BBUUIILLTTIINN__LLIIBB==_v_a_l_u_e , then the library named by
       _v_a_l_u_e will be searched for as if it were an option argument to  bbuuiillttiinn
       --ff,  and  if  it contains a built-in of the specified name this will be
       executed instead of a command by this name.  Otherwise, if this file is
       found  and  it  contains  a line of the form _n_a_m_e==_v_a_l_u_e in the first or
       second line, then the environment variable _n_a_m_e is modified by prepend-
       ing  the  directory specified by _v_a_l_u_e to the directory list.  If _v_a_l_u_e
       is not an absolute directory, then it specifies a directory relative to
       the  directory that the executable was found.  If the environment vari-
       able _n_a_m_e does not already exist it will be added  to  the  environment
       list for the specified command.

       If  the  file  has  execute  permission but is not an aa..oouutt file, it is
       assumed to be a file containing shell commands.  A  separate  shell  is
       spawned  to  read  it.   All non-exported variables are removed in this
       case.  If the shell command file doesn’t have read  permission,  or  if
       the  _s_e_t_u_i_d and/or _s_e_t_g_i_d bits are set on the file, then the shell exe-
       cutes an agent whose job it is to set up the  permissions  and  execute
       the  shell  with the shell command file passed down as an open file.  A
       parenthesized command is executed in a sub-shell without removing  non-
       exported variables.

   CCoommmmaanndd RRee--eennttrryy..
       The  text  of  the  last HHIISSTTSSIIZZEE (default 512) commands entered from a
       terminal device is saved in a _h_i_s_t_o_r_y file.  The file $$HHOOMMEE//..sshh__hhiissttoorryy
       is  used if the HHIISSTTFFIILLEE variable is not set or if the file it names is
       not writable.  A shell can  access  the  commands  of  all  _i_n_t_e_r_a_c_t_i_v_e
       shells which use the same named HHIISSTTFFIILLEE.  The built-in command hhiisstt is
       used to list or edit a portion of this file.  The portion of  the  file
       to be edited or listed can be selected by number or by giving the first
       character or characters of the command.  A single command or  range  of
       commands  can be specified.  If you do not specify an editor program as
       an argument to hhiisstt then the value of the variable  HHIISSTTEEDDIITT  is  used.
       If  HHIISSTTEEDDIITT is unset, the obsolete variable FFCCEEDDIITT is used.  If FFCCEEDDIITT
       is not defined, then //bbiinn//eedd is used.  The edited command(s) is printed
       and  re-executed  upon leaving the editor unless you quit without writ-
       ing.  The --ss option (and in obsolete versions, the editor  name  --)  is
       used  to skip the editing phase and to re-execute the command.  In this
       case a substitution parameter of the form _o_l_d==_n_e_w can be used to modify
       the  command  before  execution.  For example, with the preset alias rr,
       which is aliased to ′′hhiisstt --ss′′, typing ‘rr bbaadd==ggoooodd  cc’  will  re-execute
       the  most  recent command which starts with the letter cc, replacing the
       first occurrence of the string bbaadd with the string ggoooodd.

   IInn--lliinnee EEddiittiinngg OOppttiioonnss..
       Normally, each command line entered from a terminal  device  is  simply
       typed  followed by a nneeww--lliinnee (‘RETURN’ or ‘LINE FEED’).  If either the
       eemmaaccss, ggmmaaccss, or vvii option is active, the user  can  edit  the  command
       line.   To  be  in  either  of  these  edit modes sseett the corresponding
       option.  An editing option is  automatically  selected  each  time  the
       VVIISSUUAALL or EEDDIITTOORR variable is assigned a value ending in either of these
       option names.

       The editing features require that the user’s terminal  accept  ‘RETURN’
       as  carriage return without line feed and that a space (‘ ’) must over-
       write the current character on the screen.

       Unless the mmuullttiilliinnee option is on, the editing modes implement  a  con-
       cept  where  the  user is looking through a window at the current line.
       The window width is the value of CCOOLLUUMMNNSS if it  is  defined,  otherwise
       80.   If  the window width is too small to display the prompt and leave
       at least 8 columns to enter input, the prompt  is  truncated  from  the
       left.  If the line is longer than the window width minus two, a mark is
       displayed at the end of the window to notify the user.  As  the  cursor
       moves  and  reaches  the  window boundaries the window will be centered
       about the cursor.  The mark is a >> (<,, **) if the line  extends  on  the
       right (left, both) side(s) of the window.

       The  search  commands  in  each edit mode provide access to the history
       file.  Only strings are matched, not patterns, although a leading ^^  in
       the  string  restricts the match to begin at the first character in the
       line.

       Each of the edit modes has an operation to list the files  or  commands
       that match a partially entered word.  When applied to the first word on
       the line, or the first word after a ;;, ││, &&, or ((, and  the  word  does
       not  begin  with  ∼∼ or contain a //, the list of aliases, functions, and
       executable commands defined by the PPAATTHH variable that could  match  the
       partial word is displayed.  Otherwise, the list of files that match the
       given word is displayed.  If the partially entered word does  not  con-
       tain  any  file expansion characters, a ** is appended before generating
       these lists.  After displaying the generated list, the  input  line  is
       redrawn.   These  operations  are  called command name listing and file
       name listing, respectively.  There are additional operations,  referred
       to  as  command name completion and file name completion, which compute
       the list of matching commands or files, but  instead  of  printing  the
       list,  replace  the current word with a complete or partial match.  For
       file name completion, if the match is unique, a // is  appended  if  the
       file is a directory and a space is appended if the file is not a direc-
       tory.  Otherwise, the longest common prefix for all the matching  files
       replaces  the  word.   For command name completion, only the portion of
       the file names after the last // are used to find  the  longest  command
       prefix.   If  only  a single name matches this prefix, then the word is
       replaced with the command name followed by a space.  When using  a  _t_a_b
       for  completion  that  does  not yield a unique match, a subsequent _t_a_b
       will provide a numbered list  of  matching  alternatives.   A  specific
       selection  can  be  made by entering the selection number followed by a
       _t_a_b.

   KKeeyy BBiinnddiinnggss..
       The KKEEYYBBDD trap can be used to intercept keys  as  they  are  typed  and
       change  the  characters that are actually seen by the shell.  This trap
       is executed after each character (or sequence of  characters  when  the
       first  character is ESC) is entered while reading from a terminal.  The
       variable ..sshh..eeddcchhaarr contains the character or character sequence  which
       generated  the  trap.   Changing  the  value  of ..sshh..eeddcchhaarr in the trap
       action causes the shell to behave as if the new value were entered from
       the keyboard rather than the original value.

       The  variable ..sshh..eeddccooll is set to the input column number of the cursor
       at the time of the input.  The variable ..sshh..eeddmmooddee is set to  ESC  when
       in  vvii  insert  mode  (see below) and is null otherwise.  By prepending
       $${{..sshh..eeddiittmmooddee}} to a value assigned to ..sshh..eeddcchhaarr  it  will  cause  the
       shell to change to control mode if it is not already in this mode.

       This trap is not invoked for characters entered as arguments to editing
       directives, or while reading input for a character search.

   EEmmaaccss EEddiittiinngg MMooddee..
       This mode is entered by enabling either the eemmaaccss or ggmmaaccss option.  The
       only  difference between these two modes is the way they handle ^^TT.  To
       edit, the user moves the cursor to the  point  needing  correction  and
       then inserts or deletes characters or words as needed.  All the editing
       commands are control characters or escape sequences.  The notation  for
       control  characters  is caret (^^) followed by the character.  For exam-
       ple, ^^FF is the notation for control FF.  This is entered  by  depressing
       ‘f’  while  holding  down the ‘CTRL’ (control) key.  The ‘SHIFT’ key is
       _n_o_t depressed.  (The notation ^^??  indicates the DEL (delete) key.)

       The notation for escape sequences is MM-- followed by a  character.   For
       example,  MM--ff  (pronounced  Meta f) is entered by depressing ESC (ascii
       003333) followed by ‘f’.  (MM--FF would be the notation for ESC  followed  by
       ‘SHIFT’ (capital) ‘F’.)

       All  edit  commands operate from any place on the line (not just at the
       beginning).  Neither the ‘RETURN’ nor the ‘LINE FEED’  key  is  entered
       after edit commands except when noted.

       ^^FF        Move cursor forward (right) one character.
       MM--[[CC      Move cursor forward (right) one character.
       MM--ff       Move  cursor forward one word.  (The eemmaaccss editor’s idea of a
                 word is a string of characters consisting  of  only  letters,
                 digits and underscores.)
       ^^BB        Move cursor backward (left) one character.
       MM--[[DD      Move cursor backward (left) one character.
       MM--bb       Move cursor backward one word.
       ^^AA        Move cursor to start of line.
       MM--[[HH      Move cursor to start of line.
       ^^EE        Move cursor to end of line.
       MM--[[YY      Move cursor to end of line.
       ^^]]_c_h_a_r    Move cursor forward to character _c_h_a_r on current line.
       MM--^^]]_c_h_a_r  Move cursor backward to character _c_h_a_r on current line.
       ^^XX^^XX      Interchange the cursor and mark.
       _e_r_a_s_e     (User  defined erase character as defined by the _s_t_t_y(1) com-
                 mand, usually ^^HH or ##.)  Delete previous character.
       _l_n_e_x_t     (User defined  literal  next  character  as  defined  by  the
                 _s_t_t_y(1)  command,  or  ^^VV  if not defined.)  Removes the next
                 character’s editing features (if any).
       ^^DD        Delete current character.
       MM--dd       Delete current word.
       MM--^^HH      (Meta-backspace) Delete previous word.
       MM--hh       Delete previous word.
       MM--^^??      (Meta-DEL) Delete previous word (if your interrupt  character
                 is ^^??  (DEL, the default) then this command will not work).
       ^^TT        Transpose  current  character  with  previous  character  and
                 advance the cursor in _e_m_a_c_s  mode.   Transpose  two  previous
                 characters in _g_m_a_c_s mode.
       ^^CC        Capitalize current character.
       MM--cc       Capitalize current word.
       MM--ll       Change the current word to lower case.
       ^^KK        Delete  from  the cursor to the end of the line.  If preceded
                 by a numerical parameter whose value is less than the current
                 cursor  position,  then  delete from given position up to the
                 cursor.  If preceded by a numerical parameter whose value  is
                 greater  than  the  current cursor position, then delete from
                 cursor up to given cursor position.
       ^^WW        Kill from the cursor to the mark.
       MM--pp       Push the region from the cursor to the mark on the stack.
       _k_i_l_l      (User defined kill character as defined by the stty  command,
                 usually ^^GG or @@.)  Kill the entire current line.  If two _k_i_l_l
                 characters are entered in  succession,  all  kill  characters
                 from  then on cause a line feed (useful when using paper ter-
                 minals).
       ^^YY        Restore last item removed from line. (Yank item back  to  the
                 line.)
       ^^LL        Line feed and print current line.
       MM--^^LL      Clear the screen.
       ^^@@        (Null character) Set mark.
       MM--_s_p_a_c_e   (Meta space) Set mark.
       ^^JJ        (New line) Execute the current line.
       ^^MM        (Return) Execute the current line.
       _e_o_f       End-of-file  character,  normally ^^DD, is processed as an End-
                 of-file only if the current line is null.
       ^^PP        Fetch previous command.  Each time ^^PP is entered the previous
                 command  back  in time is accessed.  Moves back one line when
                 not on the first line of a multi-line command.
       MM--[[AA      If the cursor is at the end of the line, it is equivalent  to
                 ^^RR with _s_t_r_i_n_g set to the contents of the current line.  Oth-
                 erwise, it is equivalent to ^^PP..
       MM--<<       Fetch the least recent (oldest) history line.
       MM-->>       Fetch the most recent (youngest) history line.
       ^^NN        Fetch next command line.  Each time ^^NN is  entered  the  next
                 command line forward in time is accessed.
       MM--[[BB      Equivalent to ^^NN..
       ^^RR_s_t_r_i_n_g  Reverse search history for a previous command line containing
                 _s_t_r_i_n_g.  If a parameter of zero is given, the search is  for-
                 ward.   _S_t_r_i_n_g is terminated by a ‘RETURN’ or ‘NEW LINE’.  If
                 string is preceded by a ^^, the matched line must  begin  with
                 _s_t_r_i_n_g.   If  _s_t_r_i_n_g  is  omitted, then the next command line
                 containing the most recent _s_t_r_i_n_g is accessed.  In this  case
                 a parameter of zero reverses the direction of the search.
       ^^OO        Operate  -  Execute  the current line and fetch the next line
                 relative to current line from the history file.
       MM--_d_i_g_i_t_s  (Escape) Define numeric parameter, the digits are taken as  a
                 parameter  to  the  next command.  The commands that accept a
                 parameter are ^^FF, ^^BB, _e_r_a_s_e, ^^CC, ^^DD, ^^KK, ^^RR, ^^PP, ^^NN, ^^]], MM--..,
                 MM--^^]], MM--__, MM--==, MM--bb, MM--cc, MM--dd, MM--ff, MM--hh, MM--ll and MM--^^HH.
       MM--_l_e_t_t_e_r  Soft-key  -  Your  alias list is searched for an alias by the
                 name ___l_e_t_t_e_r and if an alias of this  name  is  defined,  its
                 value  will  be inserted on the input queue.  The _l_e_t_t_e_r must
                 not be one of the above meta-functions.
       MM--[[_l_e_t_t_e_r Soft-key - Your alias list is searched for an  alias  by  the
                 name  _____l_e_t_t_e_r  and  if an alias of this name is defined, its
                 value will be inserted on the input queue.  This can be  used
                 to program function keys on many terminals.
       MM--..       The  last  word  of  the  previous command is inserted on the
                 line.  If preceded by a numeric parameter, the value of  this
                 parameter  determines  which  word  to insert rather than the
                 last word.
       MM--__       Same as MM--...
       MM--**       Attempt file name generation on the current word.  An  aster-
                 isk is appended if the word doesn’t match any file or contain
                 any special pattern characters.
       MM--EESSCC     Command or file name completion as described above.
       ^^II _t_a_b    Attempts command or file name completion as described  above.
                 If a partial completion occurs, repeating this will behave as
                 if MM--== were entered.  If no match is found or  entered  after
                 _s_p_a_c_e, a _t_a_b is inserted.
       MM--==       If not preceded by a numeric parameter, it generates the list
                 of matching  commands  or  file  names  as  described  above.
                 Otherwise,  the word under the cursor is replaced by the item
                 corresponding to the value of the numeric parameter from  the
                 most  recently generated command or file list.  If the cursor
                 is not on a word, it is inserted instead.
       ^^UU        Multiply parameter of next command by 4.
       \\         Escape next character.  Editing characters, the user’s erase,
                 kill  and  interrupt (normally ^^??)  characters may be entered
                 in a command line or in a search string if preceded by  a  \\.
                 The \\ removes the next character’s editing features (if any).
       MM--^^VV      Display version of the shell.
       MM--##       If the line does not begin with a ##, a ## is inserted  at  the
                 beginning  of  the line and after each new-line, and the line
                 is entered.  This causes a comment to be inserted in the his-
                 tory file.  If the line begins with a ##, the ## is deleted and
                 one ## after each new-line is also deleted.

   VVii EEddiittiinngg MMooddee..
       There are two typing modes.  Initially, when you enter  a  command  you
       are in the _i_n_p_u_t mode.  To edit, the user enters _c_o_n_t_r_o_l mode by typing
       ESC (003333) and moves the cursor to the point needing correction and then
       inserts  or  deletes  characters or words as needed.  Most control com-
       mands accept an optional repeat _c_o_u_n_t prior to the command.

       When in vvii mode on most  systems,  canonical  processing  is  initially
       enabled  and the command will be echoed again if the speed is 1200 baud
       or greater and it contains any control characters or less than one sec-
       ond has elapsed since the prompt was printed.  The ESC character termi-
       nates canonical processing for the remainder of  the  command  and  the
       user  can then modify the command line.  This scheme has the advantages
       of canonical processing with the type-ahead echoing of raw mode.

       If the option vviirraaww is also set, the terminal will always have  canoni-
       cal processing disabled.  This mode is implicit for systems that do not
       support two alternate end of line delimiters, and may  be  helpful  for
       certain terminals.

        IInnppuutt EEddiitt CCoommmmaannddss
              By default the editor is in input mode.
              _e_r_a_s_e     (User  defined  erase character as defined by the stty
                        command, usually ^^HH or ##.)  Delete previous character.
              ^^WW        Delete  the  previous  blank  separated word.  On some
                        systems the vviirraaww option may be required for  this  to
                        work.
              _e_o_f       As the first character of the line causes the shell to
                        terminate unless the iiggnnoorreeeeooff option is set.   Other-
                        wise this character is ignored.
              _l_n_e_x_t     (User defined literal next character as defined by the
                        _s_t_t_y(1) or ^^VV if not defined.)  Removes the next char-
                        acter’s  editing  features  (if any).  On some systems
                        the vviirraaww option may be required for this to work.
              \\         Escape the next _e_r_a_s_e or _k_i_l_l character.
              ^^II _t_a_b    Attempts command or file name completion as  described
                        above and returns to input mode.  If a partial comple-
                        tion occurs, repeating this will behave as if  ==  were
                        entered  from  control  mode.  If no match is found or
                        entered after _s_p_a_c_e, a _t_a_b is inserted.
        MMoottiioonn EEddiitt CCoommmmaannddss
              These commands will move the cursor.
              [_c_o_u_n_t]ll  Cursor forward (right) one character.
              [_c_o_u_n_t][[CC Cursor forward (right) one character.
              [_c_o_u_n_t]ww  Cursor forward one alpha-numeric word.
              [_c_o_u_n_t]WW  Cursor to the beginning of the next word that  follows
                        a blank.
              [_c_o_u_n_t]ee  Cursor to end of word.
              [_c_o_u_n_t]EE  Cursor to end of the current blank delimited word.
              [_c_o_u_n_t]hh  Cursor backward (left) one character.
              [_c_o_u_n_t][[DD Cursor backward (left) one character.
              [_c_o_u_n_t]bb  Cursor backward one word.
              [_c_o_u_n_t]BB  Cursor to preceding blank separated word.
              [_c_o_u_n_t]││  Cursor to column _c_o_u_n_t.
              [_c_o_u_n_t]ff_c Find the next character _c in the current line.
              [_c_o_u_n_t]FF_c Find the previous character _c in the current line.
              [_c_o_u_n_t]tt_c Equivalent to ff followed by hh.
              [_c_o_u_n_t]TT_c Equivalent to FF followed by ll.
              [_c_o_u_n_t];;  Repeats  _c_o_u_n_t  times,  the last single character find
                        command, ff, FF, tt, or TT.
              [_c_o_u_n_t],,  Reverses the last single character find command  _c_o_u_n_t
                        times.
              00         Cursor to start of line.
              ^^         Cursor to start of line.
              [[HH        Cursor to first non-blank character in line.
              $$         Cursor to end of line.
              [[YY        Cursor to end of line.
              %%         Moves  to balancing ((, )), {{, }}, [[, or ]].  If cursor is
                        not on one of the above characters, the  remainder  of
                        the  line  is searched for the first occurrence of one
                        of the above characters first.
        SSeeaarrcchh EEddiitt CCoommmmaannddss
              These commands access your command history.
              [_c_o_u_n_t]kk  Fetch previous command.  Each time kk  is  entered  the
                        previous command back in time is accessed.
              [_c_o_u_n_t]--  Equivalent to kk.
              [_c_o_u_n_t][[AA If  cursor  is at the end of the line it is equivalent
                        to // with _s_t_r_i_n_g_^_s_e_t _t_o _t_h_e _c_o_n_t_e_n_t_s  _o_f  _t_h_e  _c_u_r_r_e_n_t
                        _l_i_n_e_.  Otherwise, it is equivalent to kk.
              [_c_o_u_n_t]jj  Fetch  next  command.  Each time jj is entered the next
                        command forward in time is accessed.
              [_c_o_u_n_t]++  Equivalent to jj.
              [_c_o_u_n_t][[BB Equivalent to jj.
              [_c_o_u_n_t]GG  The command number _c_o_u_n_t is fetched.  The  default  is
                        the least recent history command.
              //_s_t_r_i_n_g   Search backward through history for a previous command
                        containing _s_t_r_i_n_g.  _S_t_r_i_n_g is terminated by a ‘RETURN’
                        or  ‘NEW LINE’.   If  string  is  preceded by a ^^, the
                        matched line must begin with  _s_t_r_i_n_g.   If  _s_t_r_i_n_g  is
                        null, the previous string will be used.
              ??_s_t_r_i_n_g   Same  as  //  except that search will be in the forward
                        direction.
              nn         Search for next match of the last pattern to  //  or  ??
                        commands.
              NN         Search  for  next match of the last pattern to // or ??,
                        but in reverse direction.
        TTeexxtt MMooddiiffiiccaattiioonn EEddiitt CCoommmmaannddss
              These commands will modify the line.
              aa         Enter input mode and  enter  text  after  the  current
                        character.
              AA         Append text to the end of the line.  Equivalent to $$aa.
              [_c_o_u_n_t]cc_m_o_t_i_o_n
              cc[_c_o_u_n_t]_m_o_t_i_o_n
                        Delete current character through  the  character  that
                        _m_o_t_i_o_n  would move the cursor to and enter input mode.
                        If _m_o_t_i_o_n is cc, the entire line will  be  deleted  and
                        input mode entered.
              CC         Delete  the  current character through the end of line
                        and enter input mode.  Equivalent to cc$$.
              SS         Equivalent to cccc.
              [_c_o_u_n_t]ss  Replace characters under the cursor in input mode.
              DD         Delete the current character through the end of  line.
                        Equivalent to dd$$.
              [_c_o_u_n_t]dd_m_o_t_i_o_n
              dd[_c_o_u_n_t]_m_o_t_i_o_n
                        Delete  current  character  through the character that
                        _m_o_t_i_o_n would move to.  If _m_o_t_i_o_n is  dd  ,,  the  entire
                        line will be deleted.
              ii         Enter  input  mode  and insert text before the current
                        character.
              II         Insert text before the beginning of the line.  Equiva-
                        lent to 00ii.
              [_c_o_u_n_t]PP  Place  the  previous text modification before the cur-
                        sor.
              [_c_o_u_n_t]pp  Place the previous text modification after the cursor.
              RR         Enter  input mode and replace characters on the screen
                        with characters you type overlay fashion.
              [_c_o_u_n_t]rr_c Replace the _c_o_u_n_t character(s) starting at the current
                        cursor position with _c, and advance the cursor.
              [_c_o_u_n_t]xx  Delete current character.
              [_c_o_u_n_t]XX  Delete preceding character.
              [_c_o_u_n_t]..  Repeat the previous text modification command.
              [_c_o_u_n_t]∼∼  Invert  the case of the _c_o_u_n_t character(s) starting at
                        the current cursor position and advance the cursor.
              [_c_o_u_n_t]__  Causes the _c_o_u_n_t word of the previous  command  to  be
                        appended  and  input  mode  entered.  The last word is
                        used if _c_o_u_n_t is omitted.
              **         Causes an ** to be appended to  the  current  word  and
                        file name generation attempted.  If no match is found,
                        it rings the bell.  Otherwise, the word is replaced by
                        the matching pattern and input mode is entered.
              \\         Command or file name completion as described above.
        OOtthheerr EEddiitt CCoommmmaannddss
              Miscellaneous commands.
              [_c_o_u_n_t]yy_m_o_t_i_o_n
              yy[_c_o_u_n_t]_m_o_t_i_o_n
                        Yank  current  character through character that _m_o_t_i_o_n
                        would move the cursor to and puts them into the delete
                        buffer.  The text and cursor are unchanged.
              yyyy        Yanks the entire line.
              YY         Yanks  from  current position to end of line.  Equiva-
                        lent to yy$$.
              uu         Undo the last text modifying command.
              UU         Undo all the text modifying commands performed on  the
                        line.
              [_c_o_u_n_t]vv  Returns  the  command hhiisstt --ee $${{VVIISSUUAALL::--$${{EEDDIITTOORR::--vvii}}}}
                        _c_o_u_n_t in the input buffer.  If _c_o_u_n_t is omitted,  then
                        the current line is used.
              ^^LL        Line  feed and print current line.  Has effect only in
                        control mode.
              ^^JJ        (New line) Execute the  current  line,  regardless  of
                        mode.
              ^^MM        (Return) Execute the current line, regardless of mode.
              ##         If the first character of the command  is  a  ##,  then
                        this  command deletes this ## and each ## that follows a
                        newline.  Otherwise, sends the line after inserting  a
                        ##  in  front  of each line in the command.  Useful for
                        causing the current line to be inserted in the history
                        as  a  comment  and  uncommenting previously commented
                        commands in the history file.
              [_c_o_u_n_t]==  If _c_o_u_n_t is not specified, it generates  the  list  of
                        matching  commands  or  file names as described above.
                        Otherwise, the word under the the cursor  is  replaced
                        by  the  _c_o_u_n_t  item  from the most recently generated
                        command or file list.  If the cursor is not on a word,
                        it is inserted instead.
              @@_l_e_t_t_e_r   Your  alias  list is searched for an alias by the name
                        ___l_e_t_t_e_r and if an alias of this name is  defined,  its
                        value will be inserted on the input queue for process-
                        ing.
              ^^VV        Display version of the shell.

   BBuuiilltt--iinn CCoommmmaannddss..
       The following  simple-commands  are  executed  in  the  shell  process.
       Input/Output redirection is permitted.  Unless otherwise indicated, the
       output is written on file descriptor 1 and the exit status, when  there
       is  no syntax error, is zero.  Except for ::, ttrruuee, ffaallssee, eecchhoo, nneewwggrrpp,
       and llooggiinn, all built-in commands accept ---- to indicate end of  options.
       They  also  interpret  the option ----mmaann as a request to display the man
       page onto standard error and --??  as a help request which prints a _u_s_a_g_e
       message  on standard error.  Commands that are preceded by one or two †
       symbols are special built-in commands and are treated specially in  the
       following ways:
       1.     Variable assignment lists preceding the command remain in effect
              when the command completes.
       2.     I/O redirections are processed after variable assignments.
       3.     Errors cause a script that contains them to abort.
       4.     They are not valid function names.
       5.     Words following a command preceded by †† that are in the  format
              of  a  variable assignment are expanded with the same rules as a
              variable assignment.  This means that tilde substitution is per-
              formed after the == sign and field splitting and file name gener-
              ation are not performed.  These are  called  _d_e_c_l_a_r_a_t_i_o_n  built-
              ins.

       † :: [ _a_r_g ... ]
              The command only expands parameters.

       † .. _n_a_m_e [[ _a_r_g ...... ]]
              If  _n_a_m_e  is  a function defined with the ffuunnccttiioonn _n_a_m_e reserved
              word syntax, the function is executed in the current environment
              (as  if  it had been defined with the _n_a_m_e(()) syntax.)  Otherwise
              if _n_a_m_e refers to a file, the file is read in its  entirety  and
              the commands are executed in the current shell environment.  The
              search path specified by PPAATTHH is used to find the directory con-
              taining  the  file.  If any arguments _a_r_g are given, they become
              the positional parameters while processing the  ..   command  and
              the original positional parameters are restored upon completion.
              Otherwise the positional parameters  are  unchanged.   The  exit
              status is the exit status of the last command executed.

       †† aalliiaass [ --ppttxx ]  [ _n_a_m_e[ ==_v_a_l_u_e  ] ] ...
              aalliiaass  with  no arguments prints the list of aliases in the form
              _n_a_m_e_=_v_a_l_u_e on standard output.  The --pp option  causes  the  word
              aalliiaass  to  be  inserted before each one.  When one or more argu-
              ments are given, an _a_l_i_a_s is defined for each _n_a_m_e  whose  _v_a_l_u_e
              is  given.  A trailing space in _v_a_l_u_e causes the next word to be
              checked for alias substitution.  The obsolete --tt option is  used
              to  set  and list tracked aliases.  The value of a tracked alias
              is the full pathname corresponding to the given _n_a_m_e.  The value
              becomes  undefined when the value of PPAATTHH is reset but the alias
              remains tracked.  Without the --tt option, for each  _n_a_m_e  in  the
              argument list for which no _v_a_l_u_e is given, the name and value of
              the alias is printed.  The obsolete --xx  option  has  no  effect.
              The  exit  status  is non-zero if a _n_a_m_e is given, but no value,
              and no alias has been defined for the _n_a_m_e.

       bbgg [ _j_o_b... ]
              This command is only on systems that support job control.   Puts
              each  specified _j_o_b into the background.  The current job is put
              in the background if _j_o_b is  not  specified.   See  _J_o_b_s  for  a
              description of the format of _j_o_b.

       † bbrreeaakk [ _n ]
              Exit  from  the  enclosing ffoorr, wwhhiillee, uunnttiill, or sseelleecctt loop, if
              any.  If _n is specified, then break _n levels.

       bbuuiillttiinn [ --ddss ] [ --ff _f_i_l_e ] [ _n_a_m_e ... ]
              If _n_a_m_e is not specified, and no --ff  option  is  specified,  the
              built-ins  are printed on standard output.  The --ss option prints
              only the special built-ins.  Otherwise, each _n_a_m_e represents the
              pathname  whose basename is the name of the built-in.  The entry
              point function name is determined by prepending bb__ to the built-
              in  name.  The ISO C/C++ prototype is bb___m_y_c_o_m_m_a_n_d((iinntt _a_r_g_c, cchhaarr
              **_a_r_g_v[[]], vvooiidd **_c_o_n_t_e_x_t)) for the builtin command _m_y_c_o_m_m_a_n_d  where
              _a_r_g_v  is  array  an  of _a_r_g_c elements and context is an optional
              pointer to a SShheellll__tt structure as described in <<aasstt//sshheellll..hh>>.
              Special built-ins cannot be bound to a pathname or deleted.  The
              --dd  option deletes each of the given built-ins.  On systems that
              support dynamic loading, the --ff option names  a  shared  library
              containing  the  code  for built-ins.  The shared library prefix
              and/or suffix, which depend on the system, can be omitted.  Once
              a library is loaded, its symbols become available for subsequent
              invocations of bbuuiillttiinn.  Multiple  libraries  can  be  specified
              with separate invocations of the bbuuiillttiinn command.  Libraries are
              searched in the reverse order in which they are specified.  When
              a  library  is  loaded,  it  looks for a function in the library
              whose name is lliibb__iinniitt(()) and invokes this function with an argu-
              ment of 00.

       ccdd [ --LLPP ] [ _a_r_g ]
       ccdd [ --LLPP ] _o_l_d _n_e_w
              This  command  can be in either of two forms.  In the first form
              it changes the current directory to _a_r_g.  If _a_r_g is -- the direc-
              tory  is  changed to the previous directory.  The shell variable
              HHOOMMEE is the default _a_r_g.  The variable PPWWDD is set to the current
              directory.   The  shell  variable CCDDPPAATTHH defines the search path
              for the directory containing _a_r_g.  Alternative  directory  names
              are separated by a colon (::).  The default path is <<nnuullll>> (spec-
              ifying the current directory).  Note that the current  directory
              is  specified  by a null path name, which can appear immediately
              after the equal sign or between the  colon  delimiters  anywhere
              else  in  the path list.  If _a_r_g begins with a // then the search
              path is not used.  Otherwise, each  directory  in  the  path  is
              searched for _a_r_g.
              The  second form of ccdd substitutes the string _n_e_w for the string
              _o_l_d in the current directory name, PPWWDD, and tries to  change  to
              this new directory.
              By default, symbolic link names are treated literally when find-
              ing the directory name.  This is equivalent to  the  --LL  option.
              The  --PP  option causes symbolic links to be resolved when deter-
              mining the directory.  The last instance of --LL or --PP on the com-
              mand line determines which method is used.
              The ccdd command may not be executed by rrkksshh..  rrkksshh9933..

       ccoommmmaanndd [ --ppvvxxVV ] _n_a_m_e [ _a_r_g ... ]
              Without  the  --vv  or  --VV options, ccoommmmaanndd executes _n_a_m_e with the
              arguments given by _a_r_g.  The --pp option causes a default path  to
              be  searched  rather  than the one defined by the value of PPAATTHH.
              Functions will not be searched for when finding _n_a_m_e.  In  addi-
              tion,  if _n_a_m_e refers to a special built-in, none of the special
              properties associated with the leading daggers will be  honored.
              (For  example, the predefined alias rreeddiirreecctt==′′ccoommmmaanndd eexxeecc′′ pre-
              vents a script from terminating when an invalid  redirection  is
              given.)   With  the --xx option, if command execution would result
              in a failure because there are too many arguments, errno  EE22BBIIGG,
              the  shell will invoke command _n_a_m_e multiple times with a subset
              of the arguments on each invocation.  Arguments that occur prior
              to  the  first word that expands to multiple arguments and after
              the last word that expands to multiple arguments will be  passed
              on each invocation.  The exit status will be the maximum invoca-
              tion exit status.  With the --vv option, ccoommmmaanndd is equivalent  to
              the  built-in  wwhheennccee  command  described  below.  The --VV option
              causes ccoommmmaanndd to act like wwhheennccee --vv.

       † ccoonnttiinnuuee [ _n ]
              Resume the next iteration of the enclosing ffoorr, wwhhiillee, uunnttiill, or
              sseelleecctt loop.  If _n is specified, then resume at the _n-th enclos-
              ing loop.

       ddiissoowwnn [ _j_o_b... ]
              Causes the shell not to send a HUP signal to each given _j_o_b,  or
              all  active  jobs  if  _j_o_b is omitted, when a login shell termi-
              nates.

       eecchhoo [ _a_r_g ... ]
              When the first _a_r_g does not begin with a  -,  and  none  of  the
              arguments  contain  a  \, then eecchhoo prints each of its arguments
              separated by a space and terminated by a  new-line.   Otherwise,
              the  behavior  of  eecchhoo  is system dependent and pprriinntt or pprriinnttff
              described below should be  used.   See  _e_c_h_o(1)  for  usage  and
              description.

       †† eennuumm [ --ii  ] _t_y_p_e[=(_v_a_l_u_e ...) ]
              Creates a declaration command named _t_y_p_e that is an integer type
              that allows one of the specified _v_a_l_u_es  as  enumeration  names.
              If  ==((_v_a_l_u_e _._._.))  is omitted, then _t_y_p_e must be an indexed array
              variable with at least two elements and  the  values  are  taken
              from  this  array  variable.   If --ii is specified the values are
              case insensitive.

       † eevvaall [ _a_r_g ... ]
              The arguments are read as input to the shell and  the  resulting
              command(s) executed.

       † eexxeecc [ --cc ] [ --aa _n_a_m_e ] [ _a_r_g ... ]
              If  _a_r_g is given, the command specified by the arguments is exe-
              cuted in place of this shell without  creating  a  new  process.
              The --cc option causes the environment to be cleared before apply-
              ing variable assignments associated with  the  eexxeecc  invocation.
              The  --aa  option causes _n_a_m_e rather than the first _a_r_g, to become
              aarrggvv[[00]] for the new process.  Input/output arguments may  appear
              and affect the current process.  If _a_r_g is not given, the effect
              of this command is to modify file descriptors as  prescribed  by
              the  input/output  redirection  list.   In  this  case, any file
              descriptor numbers greater than 2  that  are  opened  with  this
              mechanism are closed when invoking another program.

       † eexxiitt [ _n ]
              Causes  the  shell  to exit with the exit status specified by _n.
              The value will be the least significant 8 bits of the  specified
              status.   If  _n  is omitted, then the exit status is that of the
              last command executed.  An end-of-file will also cause the shell
              to  exit  except for a shell which has the iiggnnoorreeeeooff option (see
              sseett below) turned on.

       †† eexxppoorrtt [ --pp ] [ _n_a_m_e[==_v_a_l_u_e] ] ...
              If _n_a_m_e is not given, the names and values of each variable with
              the  export  attribute  are  printed with the values quoted in a
              manner that allows them to be re-input.  The  --pp  option  causes
              the  word eexxppoorrtt to be inserted before each one.  Otherwise, the
              given _n_a_m_es are marked for automatic export to  the  _e_n_v_i_r_o_n_m_e_n_t
              of subsequently-executed commands.

       ffaallssee  Does nothing, and exits 1. Used with uunnttiill for infinite loops.

       ffgg [ _j_o_b... ]
              This  command is only on systems that support job control.  Each
              _j_o_b specified is brought to the foreground and waited for in the
              specified order.  Otherwise, the current job is brought into the
              foreground.  See _J_o_b_s for a description of the format of _j_o_b.

       ggeettccoonnff [ _n_a_m_e [ _p_a_t_h_n_a_m_e ] ]
              Prints the current value of the configuration parameter given by
              _n_a_m_e.   The  configuration  parameters  are  defined by the IEEE
              POSIX 1003.1 and IEEE POSIX 1003.2 standards.  (See  _p_a_t_h_c_o_n_f(2)
              and  _s_y_s_c_o_n_f(2).)  The _p_a_t_h_n_a_m_e argument is required for parame-
              ters whose value depends on the location in the file system.  If
              no  arguments  are given, ggeettccoonnff prints the names and values of
              the current configuration parameters.  The pathname  //  is  used
              for each of the parameters that requires _p_a_t_h_n_a_m_e.

       ggeettooppttss [  --aa _n_a_m_e ] _o_p_t_s_t_r_i_n_g _v_n_a_m_e [ _a_r_g ... ]
              Checks _a_r_g for legal options.  If _a_r_g is omitted, the positional
              parameters are used.  An option argument begins with a ++ or a --.
              An  option not beginning with ++ or -- or the argument ---- ends the
              options.  Options beginning with ++ are only recognized when _o_p_t_-
              _s_t_r_i_n_g  begins  with  a  ++.  _o_p_t_s_t_r_i_n_g contains the letters that
              ggeettooppttss recognizes.  If a letter is followed by a ::, that option
              is  expected  to have an argument.  The options can be separated
              from the argument by blanks.  The option --??  causes  ggeettooppttss  to
              generate a usage message on standard error.  The --aa argument can
              be used to specify the name to use for the usage message,  which
              defaults to $$00.
              ggeettooppttss  places  the next option letter it finds inside variable
              _v_n_a_m_e each time it  is  invoked.   The  option  letter  will  be
              prepended  with  a ++ when _a_r_g begins with a ++.  The index of the
              next _a_r_g is stored in OOPPTTIINNDD.  The option argument, if any, gets
              stored in OOPPTTAARRGG.
              A  leading  :: in _o_p_t_s_t_r_i_n_g causes ggeettooppttss to store the letter of
              an invalid option in OOPPTTAARRGG, and to  set  _v_n_a_m_e  to  ??   for  an
              unknown option and to :: when a required option argument is miss-
              ing.  Otherwise, ggeettooppttss prints an error message.  The exit sta-
              tus is non-zero when there are no more options.
              There is no way to specify any of the options ::, ++, --, ??, [[, and
              ]].  The option ## can only be specified as the first option.

       hhiisstt [ --ee _e_n_a_m_e  ] [ --nnllrr ] [ _f_i_r_s_t [ _l_a_s_t ] ]
       hhiisstt --ss  [ _o_l_d==_n_e_w ] [ _c_o_m_m_a_n_d ]
              In the first form, a range of commands from  _f_i_r_s_t  to  _l_a_s_t  is
              selected  from the last HHIISSTTSSIIZZEE commands that were typed at the
              terminal.  The arguments _f_i_r_s_t and _l_a_s_t may be  specified  as  a
              number  or  as  a  string.   A string is used to locate the most
              recent command starting with the given string.  A negative  num-
              ber  is used as an offset to the current command number.  If the
              --ll option is selected, the commands are listed on standard  out-
              put.   Otherwise,  the editor program _e_n_a_m_e is invoked on a file
              containing these keyboard commands.  If _e_n_a_m_e is  not  supplied,
              then the value of the variable HHIISSTTEEDDIITT is used.  If HHIISSTTEEDDIITT is
              not set, then FFCCEEDDIITT (default //bbiinn//eedd) is used  as  the  editor.
              When  editing  is complete, the edited command(s) is executed if
              the changes have been saved.  If _l_a_s_t is not specified, then  it
              will be set to _f_i_r_s_t.  If _f_i_r_s_t is not specified, the default is
              the previous command for  editing  and  -16  for  listing.   The
              option  --rr  reverses the order of the commands and the option --nn
              suppresses command numbers when listing.  In  the  second  form,
              _c_o_m_m_a_n_d  is interpreted as _f_i_r_s_t described above and defaults to
              the last command executed.  The resulting  command  is  executed
              after the optional substitution _o_l_d==_n_e_w is performed.

       jjoobbss [ --llnnpp ] [ _j_o_b ... ]
              Lists  information  about  each given job; or all active jobs if
              _j_o_b is omitted.  The --ll option lists process ids in addition  to
              the  normal  information.  The --nn option only displays jobs that
              have stopped or exited  since  last  notified.   The  --pp  option
              causes  only  the  process  group  to be listed.  See _J_o_b_s for a
              description of the format of _j_o_b.

       kkiillll [ --ss _s_i_g_n_a_m_e ] _j_o_b ...
       kkiillll [ --nn _s_i_g_n_u_m ] _j_o_b ...
       kkiillll --ll [ _s_i_g ... ]
              Sends either the TERM (terminate) signal or the specified signal
              to the specified jobs or processes.  Signals are either given by
              number with the --nn option or by name  with  the  --ss  option  (as
              given  in  <<ssiiggnnaall..hh>>,  stripped  of the prefix ‘‘SIG’’ with the
              exception that SIGCLD is named CHLD).  For backward  compatibil-
              ity,  the  nn  and ss can be omitted and the number or name placed
              immediately after the --.  If the signal being sent is TERM (ter-
              minate)  or HUP (hangup), then the job or process will be sent a
              CONT (continue) signal if it is stopped.  The argument  _j_o_b  can
              be  the  process  id of a process that is not a member of one of
              the active jobs.  See _J_o_b_s for a description of  the  format  of
              _j_o_b.   In  the third form, kkiillll --ll, if _s_i_g is not specified, the
              signal names are listed.  Otherwise, for  each  _s_i_g  that  is  a
              name,  the  corresponding signal number is listed.  For each _s_i_g
              that is a number, the signal name  corresponding  to  the  least
              significant 8 bits of _s_i_g is listed.

       lleett _a_r_g ...
              Each  _a_r_g  is  a separate _a_r_i_t_h_m_e_t_i_c _e_x_p_r_e_s_s_i_o_n to be evaluated.
              See _A_r_i_t_h_m_e_t_i_c _E_v_a_l_u_a_t_i_o_n above, for a description of arithmetic
              expression evaluation.
              The exit status is 0 if the value of the last expression is non-
              zero, and 1 otherwise.

       † nneewwggrrpp [ _a_r_g ... ]
              Equivalent to eexxeecc //bbiinn//nneewwggrrpp _a_r_g ....

       pprriinntt [ --CCRReennpprrssvv ] [ --uu _u_n_i_t] [ --ff _f_o_r_m_a_t ] [ _a_r_g ... ]
              With no options or with option -- or ----, each _a_r_g is  printed  on
              standard  output.   The  --ff  option  causes  the arguments to be
              printed as described by pprriinnttff.  In this case, any ee,  nn,  rr,  RR
              options  are  ignored.   Otherwise, unless the --CC, --RR, --rr, or --vv
              are specified, the following escape conventions will be applied:
              \\aa     The alert character (ascii 0077).
              \\bb     The backspace character (ascii 001100).
              \\cc     Causes pprriinntt to end without processing more arguments and
                     not adding a new-line.
              \\ff     The formfeed character (ascii 001144).
              \\nn     The new-line character (ascii 001122).
              \\rr     The carriage return character (ascii 001155).
              \\tt     The tab character (ascii 001111).
              \\vv     The vertical tab character (ascii 001133).
              \\EE     The escape character (ascii 003333).
              \\\\     The backslash character \.
              \\00_x    The character defined by  the  1,  2,  or  3-digit  octal
                     string given by _x.

              The  --RR  option  will print all subsequent arguments and options
              other than --nn.  The --ee causes the above escape conventions to be
              applied.   This is the default behavior.  It reverses the effect
              of an earlier --rr.  The --pp option  causes  the  arguments  to  be
              written  onto the pipe of the process spawned with ││&& instead of
              standard output.  The --vv option treats each _a_r_g  as  a  variable
              name  and  writes  the  value  in  the pprriinnttff %%BB format.  The --CC
              option treats each _a_r_g as a variable name and writes  the  value
              in the pprriinnttff %%##BB format.  The --ss option causes the arguments to
              be written onto the history file  instead  of  standard  output.
              The --uu option can be used to specify a one digit file descriptor
              unit number _u_n_i_t on  which  the  output  will  be  placed.   The
              default is 1.  If the option --nn is used, no nneeww--lliinnee is added to
              the output.

       pprriinnttff _f_o_r_m_a_t [ _a_r_g ... ]
              The arguments _a_r_g are printed on standard output  in  accordance
              with  the  ANSI-C  formatting  rules  associated with the format
              string _f_o_r_m_a_t.  If the number of arguments exceeds the number of
              format  specifications,  the  ffoorrmmaatt  string is reused to format
              remaining arguments.  The following extensions can also be used:
              %%bb     A  %%bb  format  can  be used instead of %%ss to cause escape
                     sequences in the corresponding  _a_r_g  to  be  expanded  as
                     described in pprriinntt..
              %%BB     A %%BB option causes each of the arguments to be treated as
                     variable names and the binary value of variable  will  be
                     printed.  The alternate flag ## causes a compound variable
                     to be output on a single line.  This is most  useful  for
                     compound variables and variables whose attribute is --bb.
              %%HH     A %%HH format can be used instead of %%ss to cause characters
                     in _a_r_g that are special in HTML and XML to be  output  as
                     their entity name.
              %%PP     A  %%PP format can be used instead of %%ss to cause _a_r_g to be
                     interpreted as an  extended  regular  expression  and  be
                     printed as a shell pattern.
              %%RR     A  %%RR format can be used instead of %%ss to cause _a_r_g to be
                     interpreted as a shell pattern and to be  printed  as  an
                     extended regular expression.
              %%qq     A  %%qq  format  can  be  used  instead  of %%ss to cause the
                     resulting string to be quoted in a  manner  than  can  be
                     reinput to the shell.
              %%((_d_a_t_e_-_f_o_r_m_a_t))TT
                     A  %%((_d_a_t_e_-_f_o_r_m_a_t))TT format can be use to treat an argument
                     as a date/time string and to format the date/time accord-
                     ing  to  the  _d_a_t_e_-_f_o_r_m_a_t as defined for the ddaattee(1) com-
                     mand.
              %%ZZ     A %%ZZ format will output a byte whose value is 0.
              %%dd     The precision field of the %%dd format can be followed by a
                     ..  and the output base.  In this case, the ## flag charac-
                     ter causes _b_a_s_e## to be prepended.
              ##      The ## flag when used with the dd specifier without an out-
                     put  base, causes the output to be displayed in thousands
                     units with one of the suffixes kk MM GG TT PP  EE  to  indicate
                     the  unit.   The  ##  flag  when used with the ii specifier
                     causes the output to be displayed in 1024 with one of the
                     suffixes KKii MMii GGii TTii PPii EEii to indicate the unit.
              ==      The == flag has been added to center the output within the
                     specified field width.


       ppwwdd [ --LLPP ]
              Outputs the value of the  current  working  directory.   The  --LL
              option is the default; it prints the logical name of the current
              directory.  If the --PP option is given, all  symbolic  links  are
              resolved  from  the  name.  The last instance of --LL or --PP on the
              command line determines which method is used.

       rreeaadd [ --AACCpprrssvv ] [ --dd _d_e_l_i_m] [ --nn _n] [ [ --NN _n] [ [  --tt  _t_i_m_e_o_u_t]  [  --uu
       _u_n_i_t] [ _v_n_a_m_e??_p_r_o_m_p_t ] [ _v_n_a_m_e ... ]
              The shell input mechanism.  One line is read and  is  broken  up
              into  fields  using  the  characters  in IIFFSS as separators.  The
              escape character, \\, is used to remove any special  meaning  for
              the  next  character  and  for line continuation.  The --dd option
              causes the read to continue to  the  first  character  of  _d_e_l_i_m
              rather  than  new-line.  The --nn option causes at most _n bytes to
              read rather a full line but will return when reading from a slow
              device  as soon as any characters have been read.  The --NN option
              causes exactly _n to be  read  unless  an  end-of-file  has  been
              encountered  or the read times out because of the --tt option.  In
              raw mode, --rr,, the \\ character is  not  treated  specially.   The
              first  field is assigned to the first _v_n_a_m_e, the second field to
              the second _v_n_a_m_e, etc., with leftover  fields  assigned  to  the
              last _v_n_a_m_e.  When _v_n_a_m_e has the binary attribute and --nn or --NN is
              specified, the bytes that are read are stored directly into  the
              variable.   If  the --vv is specified, then the value of the first
              _v_n_a_m_e will be used as a default value when reading from a termi-
              nal device.  The --AA option causes the variable _v_n_a_m_e to be unset
              and each field that is read to be stored in successive  elements
              of  the  indexed array _v_n_a_m_e_.  The --CC option causes the variable
              _v_n_a_m_e to be read as a compound variable.  Blanks will be ignored
              when  finding  the  beginning  open  parenthesis.  The --pp option
              causes the input line to be taken from the input pipe of a  pro-
              cess  spawned  by  the  shell  using  ││&&.   If  the --ss option is
              present, the input will be saved as a  command  in  the  history
              file.   The  option  --uu  can be used to specify a one digit file
              descriptor unit _u_n_i_t to read from.  The file descriptor  can  be
              opened  with  the  eexxeecc  special  built-in command.  The default
              value of unit _n is 0.  The option --tt is used to specify a  time-
              out  in  seconds when reading from a terminal or pipe.  If _v_n_a_m_e
              is omitted, then RREEPPLLYY is used as the default _v_n_a_m_e.  An end-of-
              file  with the --pp option causes cleanup for this process so that
              another can be spawned.  If the first argument contains a ??, the
              remainder  of  this  word  is used as a _p_r_o_m_p_t on standard error
              when the shell is interactive.  The exit status is 0  unless  an
              end-of-file is encountered or rreeaadd has timed out.

       †† rreeaaddoonnllyy [ --pp ] [ _v_n_a_m_e[==_v_a_l_u_e] ] ...
              If  _v_n_a_m_e  is  not  given, the names and values of each variable
              with the readonly attribute is printed with the values quoted in
              a  manner  that  allows  them  to be re-inputted.  The --pp option
              causes the word rreeaaddoonnllyy to be inserted before each one.  Other-
              wise,  the given _v_n_a_m_es are marked readonly and these names can-
              not be changed by subsequent assignment.  When defining a  type,
              if the value of a readonly sub-variable is not defined the value
              is required when creating each instance.

       † rreettuurrnn [ _n ]
              Causes a shell _f_u_n_c_t_i_o_n or ..  script to return to  the  invoking
              script  with  the exit status specified by _n.  The value will be
              the least significant 8 bits of the specified status.  If  _n  is
              omitted, then the return status is that of the last command exe-
              cuted.  If rreettuurrnn is invoked while not in  a  _f_u_n_c_t_i_o_n  or  a  ..
              script, then it behaves the same as eexxiitt.

       †  sseett  [  ±±BBCCGGaabbeeffhhkkmmnnoopprrssttuuvvxx ] [ ±±oo [ _o_p_t_i_o_n ] ] ... [ ±±AA _v_n_a_m_e ]  [
       _a_r_g ... ]
              The options for this command have meaning as follows:
              --AA      Array  assignment.   Unset the variable _v_n_a_m_e and assign
                      values sequentially from the _a_r_g list.  If ++AA  is  used,
                      the variable _v_n_a_m_e is not unset first.
              --BB      Enable  brace  pattern  field  generation.   This is the
                      default behavior.
              --BB      Enable brace group expansion.  On by default.
              --CC      Prevents redirection >> from truncating  existing  files.
                      Files  that are created are opened with the O_EXCL mode.
                      Requires >>││ to truncate a file when turned on.
              --GG      Causes the pattern ∗∗∗∗ by itself to match files and  zero
                      or  more  directories  and sub-directories when used for
                      file name generation.  If followed by a // only  directo-
                      ries and sub-directories are matched.
              --aa      All  subsequent variables that are defined are automati-
                      cally exported.
              --bb      Prints job completion messages as soon as  a  background
                      job  changes  state  rather  than  waiting  for the next
                      prompt.
              --ee      Unless contained in a ││││ or &&&& command, or  the  command
                      following  an  iiff  wwhhiillee  or  uunnttiill  command  or  in the
                      pipeline following !!, if a command has a  non-zero  exit
                      status,  execute  the  EERRRR trap, if set, and exit.  This
                      mode is disabled while reading profiles.
              --ff      Disables file name generation.
              --hh      Each command becomes a tracked alias when first  encoun-
                      tered.
              --kk      (Obsolete). All variable assignment arguments are placed
                      in the environment for a command, not  just  those  that
                      precede the command name.
              --mm      Background jobs will run in a separate process group and
                      a line will print upon completion.  The exit  status  of
                      background jobs is reported in a completion message.  On
                      systems with job control, this option is turned on auto-
                      matically for interactive shells.
              --nn      Read  commands  and check them for syntax errors, but do
                      not execute them.  Ignored for interactive shells.
              --oo      The following argument  can  be  one  of  the  following
                      option names:
                      aalllleexxppoorrtt
                              Same as --aa.
                      eerrrreexxiitt Same as --ee.
                      bbggnniiccee  All background jobs are run at a lower priority.
                              This is the default mode.
                      bbrraacceeeexxppaanndd
                              Same as --BB.
                      eemmaaccss   Puts you in an _e_m_a_c_s style  in-line  editor  for
                              command entry.
                      gglloobbssttaarr
                              Same as --GG.
                      ggmmaaccss   Puts  you  in  a  _g_m_a_c_s style in-line editor for
                              command entry.
                      iiggnnoorreeeeooff
                              The shell will not  exit  on  end-of-file.   The
                              command eexxiitt must be used.
                      kkeeyywwoorrdd Same as --kk.
                      mmaarrkkddiirrss
                              All  directory  names  resulting  from file name
                              generation have a trailing // appended.
                      mmoonniittoorr Same as --mm.
                      mmuullttiilliinnee
                              The built-in editors will use multiple lines  on
                              the  screen  for  lines that are longer than the
                              width of the screen.  This may not work for  all
                              terminals.
                      nnoocclloobbbbeerr
                              Same as --CC.
                      nnooeexxeecc  Same as --nn.
                      nnoogglloobb  Same as --ff.
                      nnoolloogg   Do  not save function definitions in the history
                              file.
                      nnoottiiffyy  Same as --bb.
                      nnoouunnsseett Same as --uu.
                      ppiippeeffaaiill
                              A pipeline will not complete  until  all  compo-
                              nents  of  the  pipeline have completed, and the
                              return value will be the value of the last  non-
                              zero  command  to fail or zero if no command has
                              failed.
                      sshhoowwmmee  When enabled, simple commands or pipelines  pre-
                              ceded by a semicolon (;;) will be displayed as if
                              the xxttrraaccee option were enabled but will  not  be
                              executed.   Otherwise,  the  leading  ;;  will be
                              ignored.
                      pprriivviilleeggeedd
                              Same as --pp.
                      vveerrbboossee Same as --vv.
                      ttrraacckkaallll
                              Same as --hh.
                      vvii      Puts you in insert mode of a  _v_i  style  in-line
                              editor  until  you hit the escape character 003333.
                              This puts you in control mode.  A  return  sends
                              the line.
                      vviirraaww   Each character is processed as it is typed in _v_i
                              mode.
                      xxttrraaccee  Same as --xx.
                      If no option name is supplied, then the  current  option
                      settings are printed.
              --pp      Disables  processing of the $$HHOOMMEE//..pprrooffiillee file and uses
                      the file //eettcc//ssuuiidd__pprrooffiillee  instead  of  the  EENNVV  file.
                      This  mode is on whenever the effective uid (gid) is not
                      equal to the real uid (gid).  Turning  this  off  causes
                      the  effective uid and gid to be set to the real uid and
                      gid.
              --rr      Enables the restricted shell.   This  option  cannot  be
                      unset once set.
              --ss      Sort the positional parameters lexicographically.
              --tt      (Obsolete).   Exit  after reading and executing one com-
                      mand.
              --uu      Treat unset parameters as an error when substituting.
              --vv      Print shell input lines as they are read.
              --xx      Print commands and their arguments as they are executed.
              ----      Do  not  change any of the options; useful in setting $$11
                      to a value beginning with --.   If  no  arguments  follow
                      this option then the positional parameters are unset.

              As an obsolete feature, if the first _a_r_g is -- then the --xx and --vv
              options are turned off and the next _a_r_g is treated as the  first
              argument.   Using  ++  rather  than  -- causes these options to be
              turned off.  These options can also be used upon  invocation  of
              the  shell.   The  current  set  of  options may be found in $$--.
              Unless --AA is specified, the remaining arguments  are  positional
              parameters  and  are  assigned,  in  order, to $$11 $$22 ....  If no
              arguments are given, then the names and values of all  variables
              are printed on the standard output.

       † sshhiifftt [ _n ]
              The  positional  parameters  from $$_n++11 ...  are renamed $$11 ... ,
              default _n is 1.  The parameter _n can be any  arithmetic  expres-
              sion  that evaluates to a non-negative number less than or equal
              to $$##.

       sslleeeepp _s_e_c_o_n_d_s
              Suspends execution for the number of decimal  seconds  or  frac-
              tions of a second given by _s_e_c_o_n_d_s.

       † ttrraapp [ --pp ] [ _a_c_t_i_o_n ] [ _s_i_g ] ...
              The  --pp  option causes the trap action associated with each trap
              as specified by the arguments to  be  printed  with  appropriate
              quoting.   Otherwise,  _a_c_t_i_o_n will be processed as if it were an
              argument to eevvaall when the shell receives  signal(s)  _s_i_g.   Each
              _s_i_g can be given as a number or as the name of the signal.  Trap
              commands are executed in order of signal number.  Any attempt to
              set  a trap on a signal that was ignored on entry to the current
              shell is ineffective.  If _a_c_t_i_o_n is omitted and the first _s_i_g is
              a  number,  or if _a_c_t_i_o_n is --, then the trap(s) for each _s_i_g are
              reset to their original values.  If _a_c_t_i_o_n is  the  null  string
              then  this signal is ignored by the shell and by the commands it
              invokes.  If _s_i_g is EERRRR then _a_c_t_i_o_n will be executed whenever  a
              command has a non-zero exit status.  If _s_i_g is DDEEBBUUGG then _a_c_t_i_o_n
              will be executed before each command.  The variable  ..sshh..ccoommmmaanndd
              will  contain  the  contents  of  the  current command line when
              _a_c_t_i_o_n is running.  If the exit status of the trap is 22 the com-
              mand  will  not  be executed.  If the exit status of the trap is
              225555 and inside a function or a dot script, the function  or  dot
              script  will return.  If _s_i_g is 00 or EEXXIITT and the ttrraapp statement
              is executed inside the body of a function defined with the ffuunncc--
              ttiioonn  _n_a_m_e syntax, then the command _a_c_t_i_o_n is executed after the
              function completes.  If _s_i_g is 00 or EEXXIITT for a ttrraapp set  outside
              any  function  then  the command _a_c_t_i_o_n is executed on exit from
              the shell.  If _s_i_g is KKEEYYBBDD, then _a_c_t_i_o_n will be executed  when-
              ever  a key is read while in eemmaaccss, ggmmaaccss, or vvii mode.  The ttrraapp
              command with no arguments prints a list of  commands  associated
              with each signal number.

       An  eexxiitt  or  rreettuurrnn without an argument in a trap action will preserve
       the exit status of the command that invoked the trap.

       ttrruuee   Does nothing, and exits 0. Used with wwhhiillee for infinite loops.

       ttrruuee   Does nothing, and exits 0. Used with wwhhiillee for infinite loops.

       †† ttyyppeesseett [ ±±AACCHHSSffllbbnnpprrttuuxx ] [ ±±EEFFLLRRXXZZii[[_n]] ]]  [[ --TT _t_n_a_m_e==((_a_s_s_i_g_n___l_i_s_t))
       ]] [[ --hh _s_t_r ]] [[ --aa [[_t_y_p_e]] ]] [[ _v_n_a_m_e[[==_v_a_l_u_e ]]  ]] ......
              Sets attributes and values for shell  variables  and  functions.
              When  invoked  inside  a function defined with the ffuunnccttiioonn _n_a_m_e
              syntax, a new instance of the variable _v_n_a_m_e is created, and the
              variable’s  value  and  type are restored when the function com-
              pletes.  The following list of attributes may be specified:
              --AA     Declares _v_n_a_m_e to be an  associative  array.   Subscripts
                     are strings rather than arithmetic expressions.
              --CC     causes each _v_n_a_m_e to be a compound variable.  _v_a_l_u_e names
                     a compound variable it is copied into _v_n_a_m_e.   Otherwise,
                     it unsets each _v_n_a_m_e.
              --aa     Declares _v_n_a_m_e to be an indexed array.  If _t_y_p_e is speci-
                     fied, it must be the name of an enumeration type  created
                     with the eennuumm command and it allows enumeration constants
                     to be used as subscripts.
              --EE     Declares _v_n_a_m_e to be a double  precision  floating  point
                     number.   If _n is non-zero, it defines the number of sig-
                     nificant figures that  are  used  when  expanding  _v_n_a_m_e.
                     Otherwise, ten significant figures will be used.
              --FF     Declares  _v_n_a_m_e  to  be a double precision floating point
                     number.  If _n is  non-zero,  it  defines  the  number  of
                     places after the decimal point that are used when expand-
                     ing _v_n_a_m_e.  Otherwise ten places after the decimal  point
                     will be used.
              --HH     This  option  provides  UNIX to host-name file mapping on
                     non-UNIX machines.
              --LL     Left justify and remove leading blanks from _v_a_l_u_e.  If  _n
                     is non-zero, it defines the width of the field, otherwise
                     it is determined by the  width  of  the  value  of  first
                     assignment.   When  the  variable  is  assigned to, it is
                     filled on the right with blanks or truncated,  if  neces-
                     sary,  to  fit  into  the field.  The --RR option is turned
                     off.
              --RR     Right justify and fill with leading blanks.  If _n is non-
                     zero,  it defines the width of the field, otherwise it is
                     determined by the width of the value of first assignment.
                     The  field  is  left filled with blanks or truncated from
                     the end if the variable is reassigned.  The --LL option  is
                     turned off.
              --SS     When used within the _a_s_s_i_g_n___l_i_s_t of a type definition, it
                     causes the specified sub-variable to  be  shared  by  all
                     instances  of  the  type.   When  used  inside a function
                     defined with the ffuunnccttiioonn reserved  word,  the  specified
                     variables  will  have  _f_u_n_c_t_i_o_n _s_t_a_t_i_c scope.  Otherwise,
                     the variable is unset prior to processing the  assignment
                     list.
              --TT     Creates  a type named by _t_n_a_m_e using the compound assign-
                     ment _a_s_s_i_g_n___l_i_s_t to _t_n_a_m_e.
              --XX     Declares _v_n_a_m_e to be a double  precision  floating  point
                     number  and expands using the %%aa format of ISO-C99.  If _n
                     is non-zero, it defines the number of  hex  digits  after
                     the  radix  point that is used when expanding _v_n_a_m_e.  The
                     default is 10.
              --ZZ     Right justify and fill with leading zeros  if  the  first
                     non-blank  character is a digit and the --LL option has not
                     been set.  Remove leading zeros if the --LL option is  also
                     set.   If  _n  is  non-zero,  it  defines the width of the
                     field, otherwise it is determined by  the  width  of  the
                     value of first assignment.
              --ff     The  names  refer  to function names rather than variable
                     names.  No assignments can be made  and  the  only  other
                     valid  options are --tt, --uu and --xx.  The --tt option turns on
                     execution tracing  for  this  function.   The  --uu  option
                     causes  this  function to be marked undefined.  The FFPPAATTHH
                     variable will be searched to find the function definition
                     when  the  function  is  referenced.  If no options other
                     than --ff is specified, then the function  definition  will
                     be  displayed  on  standard  output.  If ++ff is specified,
                     then a line containing the function name  followed  by  a
                     shell comment containing the line number and path name of
                     the file where this function was defined, if any, is dis-
                     played.
              --bb     The  variable  can hold any number of bytes of data.  The
                     data can be text or binary.  The value is represented  by
                     the  base64  encoding  of the data.  If --ZZ is also speci-
                     fied, the size in bytes of the data in the buffer will be
                     determined  by  the  size associated with the --ZZ.  If the
                     base64 string assigned results in more data, it  will  be
                     truncated.  Otherwise, it will be filled with bytes whose
                     value is zero.  The pprriinnttff format %%BB can be used to  out-
                     put  the actual data in this buffer instead of the base64
                     encoding of the data.
              --hh     Used within type definitions to add information when gen-
                     erating  information  about  the  sub-variable on the man
                     page.  It is ignored when used outside of a type  defini-
                     tion.   When  used  with --ff the information is associated
                     with the corresponding discipline function.
              --ii     Declares _v_n_a_m_e to be represented internally  as  integer.
                     The  right  hand side of an assignment is evaluated as an
                     arithmetic expression when assigning to an integer.  If _n
                     is  non-zero, it defines the output arithmetic base, oth-
                     erwise the output base will be ten.
              --ll     All upper-case characters are  converted  to  lower-case.
                     The upper-case option, --uu, is turned off.
              --nn     Declares  _v_n_a_m_e  to  be a reference to the variable whose
                     name is defined by the value of variable _v_n_a_m_e.  This  is
                     usually  used  to  reference a variable inside a function
                     whose name has been passed as an argument.
              --pp     The name, attributes and values for the given _v_n_a_m_es  are
                     written  on standard output in a form that can be used as
                     shell input.  If ++pp is specified, then the values are not
                     displayed.
              --rr     The given _v_n_a_m_es are marked readonly and these names can-
                     not be changed by subsequent assignment.
              --tt     Tags the variables.  Tags are user definable and have  no
                     special meaning to the shell.
              --uu     All  lower-case  characters  are converted to upper-case.
                     The lower-case option, --ll, is turned off.
              --xx     The given _v_n_a_m_es are marked for automatic export  to  the
                     _e_n_v_i_r_o_n_m_e_n_t of subsequently-executed commands.  Variables
                     whose names contain a ..  cannot be exported.

              The --ii attribute cannot be specified along with --RR, --LL,  --ZZ,  or
              --ff.

              Using ++ rather than -- causes these options to be turned off.  If
              no _v_n_a_m_e arguments are given, a list of _v_n_a_m_e_s  (and  optionally
              the _v_a_l_u_e_s) of the _v_a_r_i_a_b_l_e_s is printed.  (Using ++ rather than --
              keeps the values from being  printed.)   The  --pp  option  causes
              ttyyppeesseett followed by the option letters to be printed before each
              name rather than the names of the options.  If any option  other
              than  --pp  is  given,  only those variables which have all of the
              given options are printed.  Otherwise, the _v_n_a_m_es and _a_t_t_r_i_b_u_t_e_s
              of all _v_a_r_i_a_b_l_e_s that have attributes are printed.

       uulliimmiitt [ --HHSSaaccddffmmnnppssttvv ] [ _l_i_m_i_t ]
              Set  or display a resource limit.  The available resource limits
              are listed below.  Many systems do not support one  or  more  of
              these  limits.   The  limit for a specified resource is set when
              _l_i_m_i_t is specified.  The value of _l_i_m_i_t can be a number  in  the
              unit specified below with each resource, or the value uunnlliimmiitteedd.
              The --HH and --SS options specify whether the hard limit or the soft
              limit  for  the  given  resource is set.  A hard limit cannot be
              increased once it is set.  A soft limit can be increased  up  to
              the  value  of the hard limit.  If neither the HH nor SS option is
              specified, the limit applies  to  both.   The  current  resource
              limit  is printed when _l_i_m_i_t is omitted.  In this case, the soft
              limit is printed unless HH is  specified.   When  more  than  one
              resource  is  specified, then the limit name and unit is printed
              before the value.
              --aa     Lists all of the current resource limits.
              --cc     The number of 512-byte blocks on the size of core  dumps.
              --dd     The number of K-bytes on the size of the data area.
              --ff     The  number of 512-byte blocks on files that can be writ-
                     ten by the current process or by child  processes  (files
                     of any size may be read).
              --mm     The number of K-bytes on the size of physical memory.
              --nn     The number of file descriptors plus 1.
              --pp     The number of 512-byte blocks for pipe buffering.
              --ss     The number of K-bytes on the size of the stack area.
              --tt     The number of CPU seconds to be used by each process.
              --vv     The number of K-bytes for virtual memory.

              If no option is given, --ff is assumed.

       uummaasskk [ --SS ] [ _m_a_s_k ]
              The user file-creation mask is set to _m_a_s_k (see _u_m_a_s_k(2)).  _m_a_s_k
              can either be an octal number or a symbolic value  as  described
              in  _c_h_m_o_d(1).  If a symbolic value is given, the new umask value
              is the complement of the result of applying _m_a_s_k to the  comple-
              ment  of the previous umask value.  If _m_a_s_k is omitted, the cur-
              rent value of the mask is printed.  The  --SS  option  causes  the
              mode  to be printed as a symbolic value.  Otherwise, the mask is
              printed in octal.

       † uunnaalliiaass [ --aa ] _n_a_m_e ...
              The aliases given by the list of  _n_a_m_es  are  removed  from  the
              alias list.  The --aa option causes all the aliases to be unset.

       †uunnsseett [ --ffnnvv ] _v_n_a_m_e ...
              The  variables given by the list of _v_n_a_m_es are unassigned, i.e.,
              except  for  sub-variables  within  a  type,  their  values  and
              attributes  are erased.  For sub-variables of a type, the values
              are reset to the default value from the type definition.   Read-
              only  variables  cannot be unset.  If the --ff option is set, then
              the names refer to _f_u_n_c_t_i_o_n names.  If the  --vv  option  is  set,
              then the names refer to _v_a_r_i_a_b_l_e names.  The --ff option overrides
              --vv.  If --nn is set and _n_a_m_e is a name reference, then  _n_a_m_e  will
              be  unset  rather  than  the  variable  that it references.  The
              default is  equivalent  to  --vv.   Unsetting  LLIINNEENNOO,  MMAAIILLCCHHEECCKK,
              OOPPTTAARRGG, OOPPTTIINNDD, RRAANNDDOOMM, SSEECCOONNDDSS, TTMMOOUUTT, and __ removes their spe-
              cial meaning even if they are subsequently assigned to.

       wwaaiitt [ _j_o_b ... ]
              Wait for the specified _j_o_b and report  its  termination  status.
              If  _j_o_b  is not given, then all currently active child processes
              are waited for.  The exit status from this command  is  that  of
              the last process waited for if _j_o_b is specified; otherwise it is
              zero.  See _J_o_b_s for a description of the format of _j_o_b.

       wwhheennccee [ --aaffppvv ] _n_a_m_e ...
              For each _n_a_m_e, indicate how it would be interpreted if used as a
              command name.
              The  --vv  option  produces  a more verbose report.  The --ff option
              skips the search for functions.   The  --pp  option  does  a  path
              search  for  _n_a_m_e  even  if  name  is an alias, a function, or a
              reserved word.  The --pp option turns off the --vv option.   The  --aa
              option  is  similar  to the --vv option but causes all interpreta-
              tions of the given name to be reported.

   IInnvvooccaattiioonn..
       If the shell is invoked by _e_x_e_c(2), and the first character of argument
       zero  ($$00) is --, then the shell is assumed to be a _l_o_g_i_n shell and com-
       mands are read from //eettcc//pprrooffiillee and then from either ..pprrooffiillee  in  the
       current  directory or $$HHOOMMEE//..pprrooffiillee, if either file exists.  Next, for
       interactive shells, commands are read from the file named by performing
       parameter  expansion, command substitution, and arithmetic substitution
       on the value of the environment variable EENNVV if the  file  exists.   If
       the  --ss  option  is  not  present and _a_r_g and a file by the name of _a_r_g
       exists, then it reads and executes  this  script.   Otherwise,  if  the
       first _a_r_g does not contain a //, a path search is performed on the first
       _a_r_g to determine the name of the script to  execute.   The  script  _a_r_g
       must have execute permission and any _s_e_t_u_i_d and _s_e_t_g_i_d settings will be
       ignored.  If the script is not found on the path, _a_r_g is  processed  as
       if  it named a built-in command or function.  Commands are then read as
       described below; the following options are  interpreted  by  the  shell
       when it is invoked:

       --DD      Do  not execute the script, but output the set of double quoted
               strings preceded by a $$.  These strings are needed  for  local-
               ization of the script to different locales.
       --EE      Reads  the file named by the EENNVV variable or by $HOME/..kshrc if
               not defined after the profiles.
       --cc        If the --cc option is present, then commands are read from  the
                 first _a_r_g.  Any remaining arguments become positional parame-
                 ters starting at 00.
       --ss        If the --ss option is present or if no arguments  remain,  then
                 commands  are  read  from  the standard input.  Shell output,
                 except for the output of the _S_p_e_c_i_a_l _C_o_m_m_a_n_d_s  listed  above,
                 is written to file descriptor 2.
       --ii        If  the --ii option is present or if the shell input and output
                 are attached to a terminal (as told  by  _t_c_g_e_t_a_t_t_r(2)),  then
                 this  shell is _i_n_t_e_r_a_c_t_i_v_e.  In this case TERM is ignored (so
                 that kkiillll 00 does not kill an interactive shell) and  INTR  is
                 caught  and  ignored (so that wwaaiitt is interruptible).  In all
                 cases, QUIT is ignored by the shell.
       --rr        If the --rr option is present, the shell is a restricted shell.
       --DD        A  list of all double quoted strings that are preceded by a $$
                 will be printed on standard output and the shell  will  exit.
                 This  set  of strings will be subject to language translation
                 when the locale is not C or POSIX.  No commands will be  exe-
                 cuted.

       --PP        If  --PP or --oo pprrooffiillee is present, the shell is a profile shell
                 (see _p_f_e_x_e_c(1)).

       --RR _f_i_l_e_n_a_m_e
                 The --RR _f_i_l_e_n_a_m_e option is used to generate a cross  reference
                 database that can be used by a separate utility to find defi-
                 nitions and references for variables and commands.  The file-
                 name argument specifies the generated database. A script file
                 must be provided on the command line as well.

       The remaining options and arguments are described under the sseett command
       above.  An optional -- as the first argument is ignored.

   RRkksshh OOnnllyy..
       _R_k_s_h  is  used  to  set up login names and execution environments whose
       capabilities are more controlled than those of the standard shell.  The
       actions  of rrkksshh are identical to those of kksshh, except that the follow-
       ing are disallowed:
              Unsetting the restricted option.
              changing directory (see _c_d(1)),
              setting or unsetting the value  or  attributes  of  SSHHEELLLL,  EENNVV,
              FFPPAATTHH, or PPAATTHH,,
              specifying path or command names containing //,
              redirecting output (>>, >>||, <<>>, and >>>>).
              adding or deleting built-in commands.
              using ccoommmmaanndd --pp to invoke a command.

       The  restrictions  above  are enforced after ..pprrooffiillee and the EENNVV files
       are interpreted.

       When a command to be executed is found to be a  shell  procedure,  rrkksshh
       invokes _k_s_h to execute it.  Thus, it is possible to provide to the end-
       user shell procedures that have access to the full power of  the  stan-
       dard  shell,  while  imposing  a  limited menu of commands; this scheme
       assumes that the end-user does not have write and  execute  permissions
       in the same directory.

       The  net  effect  of these rules is that the writer of the ..pprrooffiillee has
       complete control over user  actions,  by  performing  guaranteed  setup
       actions  and leaving the user in an appropriate directory (probably _n_o_t
       the login directory).

       The system administrator often sets up a directory of  commands  (e.g.,
       //uussrr//rrbbiinn) that can be safely invoked by rrkksshh.

EEXXIITT SSTTAATTUUSS
       Errors detected by the shell, such as syntax errors, cause the shell to
       return a non-zero exit status.  If the shell is being used non-interac-
       tively,  then execution of the shell file is abandoned unless the error
       occurs inside a subshell in which case the subshell is abandoned.  Oth-
       erwise,  the shell returns the exit status of the last command executed
       (see also the eexxiitt command above).  Run time  errors  detected  by  the
       shell  are  reported  by  printing the command or function name and the
       error condition.  If the line number that  the  error  occurred  on  is
       greater than one, then the line number is also printed in square brack-
       ets ([[]]) after the command or function name.

FFIILLEESS
       //eettcc//pprrooffiillee
              The system wide initialization file, executed for login  shells.

       $$HHOOMMEE//..pprrooffiillee
              The  personal  initialization  file,  executed  for login shells
              after /etc/profile.

       $HOME/...kshrc
              Default personal initialization file, executed  for  interactive
              shells when EENNVV is not set.

       //eettcc//ssuuiidd__pprrooffiillee
              Alternative  initialization  file,  executed instead of the per-
              sonal initialization file when the real and  effective  user  or
              group id do not match.

       //ddeevv//nnuullll
              NULL device

SSEEEE AALLSSOO
       cat(1),  cd(1),  chmod(1), cut(1), egrep(1), echo(1), emacs(1), env(1),
       fgrep(1), gmacs(1), grep(1), newgrp(1),  pfexec(1),  stty(1),  test(1),
       umask(1),  vi(1),  dup(2),  exec(2),  fork(2),  getpwnam(3),  ioctl(2),
       lseek(2),  paste(1),  pathconf(2),   pipe(2),   sysconf(2),   umask(2),
       ulimit(2), wait(2), rand(3), a.out(5), profile(5), environ(7).

       Morris  I. Bolsky and David G. Korn, _T_h_e _N_e_w _K_o_r_n_S_h_e_l_l _C_o_m_m_a_n_d _a_n_d _P_r_o_-
       _g_r_a_m_m_i_n_g _L_a_n_g_u_a_g_e, Prentice Hall, 1995.

       _P_O_S_I_X _- _P_a_r_t _2_: _S_h_e_l_l _a_n_d  _U_t_i_l_i_t_i_e_s_,  IEEE  Std  1003.2-1992,  ISO/IEC
       9945-2, IEEE, 1993.

CCAAVVEEAATTSS
       If  a  command  is  executed,  and then a command with the same name is
       installed in a directory in the search path before the directory  where
       the  original  command  was  found, the shell will continue to _e_x_e_c the
       original command.  Use the --tt option of the aalliiaass  command  to  correct
       this situation.

       Some very old shell scripts contain a ^^ as a synonym for the pipe char-
       acter ││.

       Using the hhiisstt built-in command within a compound  command  will  cause
       the whole command to disappear from the history file.

       The  built-in  command  .. _f_i_l_e reads the whole file before any commands
       are executed.  Therefore, aalliiaass and uunnaalliiaass commands in the  file  will
       not apply to any commands defined in the file.

       Traps  are  not  processed while a job is waiting for a foreground pro-
       cess.  Thus, a trap on CCHHLLDD won’t be executed until the foreground  job
       terminates.

       It  is  a good idea to leave a space after the comma operator in arith-
       metic expressions to prevent the comma from being  interpreted  as  the
       decimal point character in certain locales.



RDS Standard              User Environment Utilities                    KSH(1)
